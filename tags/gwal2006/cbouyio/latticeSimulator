#!/usr/bin/env python

# latticeSimulator: A program that simulates a lattice of trannsys instances
# on a nxn lattice, each cell of the lattice cantains one transsys program.
# The program applies communication between neighbour cells and is an attempt
# to simulate the processes described in "Soile V. E. Keranen, 2004. Simulation
# study on effects of signaling network structure on the developmental
# increase in complexity."
# Start developed by CBouyio on Aprill 2006 at UEA


import getopt
import sys
import copy
import random
#import math
import os
import os.path
import shutil
import re

import transsys


def usage() :
  print """Usage:
./latticeSimulator [options] arguments
  Options:
  -h, --help:   Prints this screen.
          -a: (switch)      The animate switch. Pops a window with a graphical
                            animation of the simulator.
                            (Default: OFF)
          -b: Float         The range (%) of the borders of a uniform
                            distribution call.
                            (Default: 0.2)
          -n: NumberxNumber The size of the nxm lattice.
                            (Default: 5x5)
                            *Please be very precise on the input format, there
                            should be an 'x' separating the two numbers. Any
                            other characters are not accepted.
          -t: Integer       The number of the timesteps for the simulation.
                            (Default: 30)
          -r: Integer       The rundom number generator seed.
                            (Default: 1)
          -m: Float         The maximum value of factor concentration that can
                            be represented to the image output. The image color
                            range is 0-255 gradients of grey.
                            (Deafult: 2)
          -u: Number        The homogenisation switch. Assigns to all factor
                            concentrations the defined value. If None then the
                            simulator starts with randomized concentrations.
                            (Default: OFF)
          -s: String:Number Signal switcher, (FactorName:FactorConcentration)
                            if it is defined, a factor gets the defined
                            concentration (signal) in the beginning of the
                            simulation.
                            (Default: None)
                            *WARNING, Please be very precise on the input
                             format, there should be a colon (:) between the
                             two variables and NO whitespaces at all.
          -x: Number:Number Signal swicher, (FactorConcentration:Timestep) in
                            this case ALL the factors will get the defined
                            concentration on the defined timestep.
                            (Default: None)
                            *WARNING, as above.
          -p: (format)      Choose to print between the different fornmats.
                            (Default print everything)
                            Available formats:
                              statistics: Prints the statistics of the transsys
                                          instance collection.
                            factor_table: Prints the table of the factor
                                          concentrations with the relative
                                          timestep and the coordinates of the
                                          instance on the spatial model.
                                     ALL: Print both statistics and
                                          factor_table.
                                          (Default)

  Arguments:
     <infile>: A valid transsys program file. (.tra)
    <outfile>: The output file, the printout.

  *Both arguments are optional as the program is able to read/write from the
 STDIN/STDOUT in case of one/two arguments are ommited.
"""


class GaussianRNG :
  """Generates a Gaussian random object.
By calling the random_gauss method, produces a "random" number out of a Gauss
distribution
  """

  def __init__(self, rndseed, mu, sigma) :
    self.rng   = random.Random(rndseed)
    self.mu    = mu
    self.sigma = sigma

  def random_value(self) :
    return self.rng.gauss(self.mu, self.sigma)


class UniformRNG :
  """Generates a random object out of a Uniform distribution.
  """

  def __init__(self, rndseed) :
    self.rng = random.Random(rndseed)

  def random_value(self, a, b) :
    return self.rng.uniform(a, b)


class ConstantRNG :
  """Generates a "random" object of constant values!
  """

# A "random" series of "1" will be produced!
  def __init__(self, constValue) :
    self.constValue = constValue

  def random_value(self) :
    return self.constValue



class TranssysInstanceCoordinates(transsys.TranssysInstance) :
  """Subclass of TranssyInstance, contains the coordinates of the instance on
the lattice.
  """

  def __init__(self, tp, coords=None, timestep=None) :
#    transsys.TranssysInstance.__init__(self, tp, timestep)
   # No need to call the old constructor, fc_stddev and fc_entropy are
   # obsolate in this context they have been implemented in the statistics
   # object.
    self.transsys_program = tp
    self.timestep = timestep
    self.factor_concentration = [0.0] * self.transsys_program.num_factors()
#   factor_concentration
    self.coordinates = []

  def time_series(self, num_timesteps) :
    """Overrides time_series and produces a timeseries with
  TranssysInstanceCoordinates instances."""
    timeseries = transsys.TranssysInstance.time_series(self, num_timesteps)
    # This list contains the timeseries with the coordinates.
    tsCoordinates = []
    for t in timeseries:
      a = TranssysInstanceCoordinates(t.transsys_program, t.timestep)
      a.transsys_program = t.transsys_program
      a.timestep = t.timestep
      a.factor_concentration = t.factor_concentration
     # No need to override these the new class doesn't need them, check
     # comments at the constructor of the class as well.
#      a.factor_concentration_stddev = t.factor_concentration_stddev
#      a.factor_concentration_entropy = t.factor_concentration_entropy
      a.coordinates = self.coordinates
      tsCoordinates.append(a)
    return tsCoordinates


class TranssysProgramLattice(transsys.TranssysInstanceCollection) :
  """The main class of the simulator, contains a lattice of transsys programs.
The main object of the simulation, is a subclass of the
TranssysInstanceCollection class of the transsys.py module.
The lattice is in a two dimensional toroidal form.
  """

  def __init__(self, tp, size) :
    """Constructor of the class."""
    # The name of the lattice.
    self.name = tp.name + '_on_a_toroidal_two_dimentional_' + str(size[0]) + 'x' + str(size[1]) + '_lattice'
    self.lattice = self.lattice_generator(tp, size)
    self.transsysProgram = tp
    self.size = size
#    self.factorConcentrations = self.generate_factor_concentrations_lattice()


  def lattice_generator(self, tp, size) :
    """Generates the lattice of transsys instances."""
    lattice = []
    for i in xrange(size[0]) :
      lattice.append([])
      for j in xrange(size[1]) :
        lattice[i].append(TranssysInstanceCoordinates(tp))
        lattice[i][j].coordinates.append(i + 1)
        lattice[i][j].coordinates.append(j + 1)
        lattice[i][j].timestep = 0
    return lattice


  def random_uniform_factor(self, fc, rng, rangeb) :
    """Returns a factor concentration out of a uniform distribution.
  Chackes for zero factor concentration and adapt the output.
  Also retarns a constant value in case of the homogenisation is set.
  """
    if homogenise == 'OFF' :
      if fc != 0 :
        fc = rng.random_value((fc - fc / rangeb), (fc + fc / rangeb))
      else :
        fc = rng.random_value(0, rangeb)
    else :
      fc = rangeb
    return fc


  def randomize_lattice (self, rng, rangeb) :
    """Randomize the factor concentrations of the lattice."""
#    k = self.transsysProgram.find_factor_index('Activator')
    for i in xrange(self.size[0]) :
      for j in xrange(self.size[1]) :
#        self.lattice[i][j].factor_concentration[k] = self.random_uniform_factor(self.lattice[i][j].factor_concentration[k], rng, rangeb)
        self.lattice[i][j].factor_concentration = map(lambda fc: self.random_uniform_factor(fc, rng, rangeb), self.lattice[i][j].factor_concentration)


#  def generate_factor_concentrations_lattice(self) :
#    """Generates a list of lists with the factor concentrations.
#Kept for legacy reasons this function is not used anymore."""
#    factorConcentrationsLattice = []
#    for i in xrange(len(self.lattice)) :
#      factorConcentrationsLattice.append([])
#      for j in xrange(len(self.lattice[i])) :
#        factorConcentrationsLattice[i].append(self.lattice[i][j].factor_concentration)
#    return factorConcentrationsLattice


  def get_transsys_program(self) :
    """Overrides the get_transsys_program method of the superclass."""
    return self.transsysProgram


  def transsys_instance_list(self) :
    """Overrides the transsys_instance_list method of the superclass."""
    ti_list = []
    for i in xrange(len(self.lattice)) :
      for j in xrange(len(self.lattice[i])) :
        ti_list.append(self.lattice[i][j])
    return ti_list


  def write_table_header(self, f) :
    """Overrides the write_table_header method of the superclass."""
    f.write('# Table of coordinated (i,j) factor concentrations (Header)\n')
    f.write('timestep i j')
    for factor in self.transsysProgram.factor_list :
      f.write(' %s' % factor.name)
    f.write('\n')


  def write_table(self, f) :
    """Overrides the write_table method of the superclass."""
    for ti in self.transsys_instance_list() :
      if ti.timestep is None :
        f.write('NA')
      else :
        f.write('%i' % ti.timestep)
#      if len(self.transsys_instance_list()) == 1 :  # Reduntant loop
#        f.write(' 1,1')
#      else :
      f.write(' %i %i' % (ti.coordinates[0], ti.coordinates[1]))
      for c in ti.factor_concentration :
        f.write(' %1.17e' % c)
      f.write('\n')


  def update_factor_concentrations(self, currentState, size, rndseed) :
    """The update function of the simulator, calculates the instances of the
  next timestep.
  Careful usage of the factor concentrations...
    """
    # Calculate the updated factor concentrations.
    # All the instances in the lattice are interacting with the 4 neighbour
    # cells, the instances in the edges are interacting with the opposite
    # cells forming the toroidal.
    # First assign the dimensions of the lattice.
    x = size[0]
    y = size[1]
    latticeFactorConcentrations = []
    # Include some noise or not.
#    rng = GaussianRNG(rndseed, 0, 0.1)
    rng = ConstantRNG(0)
    for i in xrange(len(self.lattice)) :
      latticeFactorConcentrations.append([])
      for j in xrange(len(self.lattice[i])) :
        # The factor concentrations manipulation.
        factorConcentrationsUpdate = [0.0] * self.transsysProgram.num_factors()
        # Get the current lattice concentrations.
        factorConcentrationsOld = currentState[i][j].factor_concentration
        if len(factorConcentrationsOld) != len(factorConcentrationsUpdate) :
          raise StandardError, 'Factor number inconsistancy between the new and the old factor concentrations list.'
        for k in xrange(len(factorConcentrationsUpdate)) :
          # The main calculation of the new factor concentrations.
          # Introduce "per factor" diffusibility expression.
          p = self.transsysProgram.factor_list[k].diffusibility_expression.value
          # Check the toroidal transformations by using the modulo division!
          fc = (factorConcentrationsOld[k] + (rng.random_value() + (p * self.lattice[(x + i - 1) % x][j].factor_concentration[k])) + (rng.random_value() + (p * self.lattice[i][(y + j - 1) % y].factor_concentration[k])) + (rng.random_value() + (p * self.lattice[i][(j + 1) % y].factor_concentration[k])) + (rng.random_value() + (p * self.lattice[(i + 1) % x][j].factor_concentration[k]))) / (4 * p + 1)
          factorConcentrationsUpdate[k] = fc
        latticeFactorConcentrations[i].append(factorConcentrationsUpdate)
    return latticeFactorConcentrations


  def update_function(self, timesteps, rndseed) :
    """Calculates the new transsys instance."""
#    for n in xrange(timesteps) :
    # Produce a copy of the current state of the simulator.
    currentState = self.lattice ## Kludge
    updateFactorConcentrations = self.update_factor_concentrations(currentState, self.size, rndseed)
    for i in xrange(len(self.lattice)) :
      for j in xrange(len(self.lattice[i])) :
        if len(self.lattice[i][j].factor_concentration) != len(updateFactorConcentrations[i][j]) :
          raise StandardError, 'update_function Error. Factor number inconsistancy'
        else :
          self.lattice[i][j].factor_concentration = updateFactorConcentrations[i][j]
          # The timeseries doesn't work with timestep 1, returns zero.
          # Thats why a timestep = 2 is used.
          # FIXME: The number of timesteps of each transsys instance on the
          # lattice timeseries is awlays one because of the usage of timestep
          # one all the time. Update it, to take the number of the current
          # timestep.
          self.lattice[i][j] = self.lattice[i][j].time_series(2)[1]
          self.lattice[i][j].timestep = (timesteps + 1)


  def signal_factor_concentration(self, xCenter, yCenter, signal, factor) :
    """Sets the factor concentration to signal."""
    for i in xCenter :
      for j in yCenter :
        if factor == None :
          self.lattice[i][j].factor_concentration = [signal for fc in self.lattice[i][j].factor_concentration]
        elif factor:
          k = self.transsysProgram.find_factor_index(factor)
          self.lattice[i][j].factor_concentration[k] = signal


  def introduce_signal(self, signalC, xFactor = None) :
    """Sets a specific factor concentration to the declared value, or sets all
  the factor conscentrations of the speciffic timestep to the declared value.
    """
    # Check for the existance of the xFactor.
    if xFactor != None :
      if not xFactor in self.transsysProgram.factor_names() :
        raise StandardError, 'Factor %s is not a valid %s factor name. Please specify a valid factor name.' % (xFactor, self.transsysProgram.name)
    # Find the center of the lattice.
    # If abscissa is odd number.
    if divmod(self.size[0], 2)[1] == 1 :
      i = [divmod(self.size[0], 2)[0]]
    # If abscissa is even number.
    elif divmod(self.size[0], 2)[1] == 0 :
      q = divmod(self.size[0], 2)[0]
      i = range(q - 1, q + 1)
    # If ordinate is odd.
    if divmod(self.size[1], 2)[1] == 1 :
      j = [divmod(self.size[1], 2)[0]]
    # If ordinate is even.
    elif divmod(self.size[1], 2)[1] == 0 :
      q = divmod(self.size[1], 2)[0]
      j = range(q - 1, q + 1)
    # Call the signal_factor_concentration function.
    self.signal_factor_concentration(i, j, signalC, xFactor)
    #######
    # Alternatively, set a randomly choosen factor concentration.
#    k = random.randint(0, (self.ranssysProgram.num_factors() - 1))
#    self.lattice[i][j].factor_concentration[k] = random.gauss(signalC, 1)
#     # Randomize factor concentrations NOT USED anymore.
#     k = random.randint(0, (self.transsysProgram.num_factors() - 1))
      # Alternatively, set a randomly choosen factor concentration.
#      k = random.randint(0, (self.transsysProgram.num_factors() - 1))
#      self.lattice[i][j].factor_concentration[k] = random.gauss(signalC, 1)


class LatticeFigure :
  """This class contains an imagefile (in raw image .pgm format) of a transsys
lattice.
  """

  def __init__(self, transsysLattice, cd) :
    self.figure = self.produce_row_format(transsysLattice, cd)


  # Function kept for lecgacy reasons after the introduction of the user defined
  # maximum accepted factor concentration value, there is no need for this
  # anymore.
  def flatten_lattice(self, factorConcentrationsLattice) :
    """Flattens the factor concentration lattice to a single list.
  Kept for legacy reasons, this function is not called anymore.
    """
    flatfactorConcentrations = []
    for i in xrange(len(factorConcentrationsLattice)) :
      for j in xrange(len(factorConcentrationsLattice[i])) :
        for fc in factorConcentrationsLattice[i][j] :
          flatfactorConcentrations.append(fc)
    return flatfactorConcentrations


  def produce_row_format(self, transsysLattice, maxC) :
   """Produces a Netpbm raster image file.
  Suitable for view/analyse with the Imagemagick graphics package.
   """
   # Generate the apropriate .pgm image format.
   pgmMagic = 'P2' # .pgm file magic line, P2 for .pgm,
   pgmComment = '# ' + transsysLattice.name + ' .pgm image of ' + ' timestep'
   pgmSize = str(transsysLattice.size[1]) + ' ' + str(transsysLattice.size[0])
   pgmMaxval = 255
   pgmRaster = ''
   # Code kept for legacy reasons, after the introduction of the user defined
   # maximum accepted factor concentration for the image gradient, this rather
   # strange approach has been replaced by a more resonable one.
   # All this approach has been substitute with a simplier way to deal with the color range of the images. Check the next code chunks.
#   flattenFCL = self.flatten_lattice(transsysLattice.generate_factor_concentrations_lattice())
#   maxValue = math.ceil(max(flattenFCL))
#   # Not so nice trick to avoid division by zero later.
#   if maxValue == 0.0 :
#     maxValue = 1e-99
   for i in xrange(transsysLattice.size[0]) :
     pgmRasterLine = ''
     for j in xrange(transsysLattice.size[1]) :
#       # Calibration within the color interval.
#       # The calibration procesure has been simplified now and a user defined
#       # maximum printing factor concentration has been introduced, Keeping
#       # this code for legacy reasons..
#       p = pgmMaxval - int(math.floor(((sum(transsysLattice.lattice[i][j].factor_concentration)) / (len(transsysLattice.lattice[i][j].factor_concentration) * maxValue) * pgmMaxval)))
       # The new simplified way to deal with the color gradients versus factor
       # concentrations.
       #FIXME: this should simplified more and produce one image file for EACH
       # factor at more complicated transsys programs.
       p = pgmMaxval - int(round(((sum(transsysLattice.lattice[i][j].factor_concentration) * pgmMaxval) / maxC)))
       pgmRasterLine = pgmRasterLine + str(p) + ' '
     pgmRaster = pgmRaster + pgmRasterLine + '\n'
   pgmText = pgmMagic + '\n' + pgmComment + '\n' + pgmSize + '\n' + str(pgmMaxval)  + '\n' + pgmRaster
   return pgmText



# Simulation Parameter Initialization.
latticeSize      = [5, 5] # The dimensions of the lattice.
noTimesteps      = 30     # The running timesteps of the simulation.
randomSeed       = 1      # The seed for the random number generators.
maxConcentration = 2      # The maximum of concentration that can be drawn.
signalT          = False  # The 'signal on a timestep', introduction switch.
signalF          = False  # The 'signal of a factor', introduction switch.
animate          = False  # The animation switch.
printFormat      = 'ALL'  # The default printing format.
border_range     = 0.2    # The border range (%) of the uniform distribution.
homogenise       = 'OFF'  # The homogenisation switch.
#signalTimestep        = 10
#signalConcentration   = 10


# Command line parsing.
try :
  optlist, args = getopt.getopt(sys.argv[1:], 'a b: h m: n: p: r: s: t: u: x:', ['help'])
except getopt.GetoptError, errorMessage :
  errorMessage = 'Error in arguments parsing, please give -h or --help for help '
  print errorMessage
  sys.exit(1)

for opt, par in optlist :
  if opt in ('-h', '--help') :
    usage()
    sys.exit()
  if opt in ('-n') :
    x = re.compile('x')
    if x.search(par) :
      latticeSize = x.split(par)
      latticeSize = map(lambda x:int(x), latticeSize)
    else :
      raise TypeError, 'Error in the format of -n input options, please check the help (-h, --help) for more information'
#    latticeSize = int(par)
  if opt in ('-t') :
    noTimesteps = int(par)
  if opt in ('-r') :
    if par :
      randomSeed = float(par)
    else :
      randomSeed = None
  if opt in ('-m') :
    maxConcentration = float(par)
  if opt in ('-x') :
    var = par.split(':')
    if len(var) != 2 :
      raise TypeError, 'Error in the format of -x input options, please check the help (-h, --help) for more information.'
    if float(var[0]) :
    # No need to raise an exeption Python will raise one for you!!!
#      raise TypeError, 'Please give a valid floating point representation for the concentration parameter, Check help (--help) for more information.'
      signalT = True
      signalConcentration = float(var[0])
      signalTimestep = int(var[1])
  if opt in ('-s') :
    var = par.split(':')
    if len(var) != 2 :
      raise TypeError, 'Error in the format of -s input options, please check the help (-h, --help) for more information.'
    if float(var[1]) :
      signalF = True
      xFactorName = var[0]
      xFactorConcentration = float(var[1])
  if opt in ('-a') :
    animate = True
  if opt in ('-p') :
    printFormat = str(par)
  if opt in ('-b') :
    border_range = float(par)
  if opt in ('-u') :
    homogenise = float(par)

#print optlist


# I/O manipulation.
if len(args) > 0 :
  infile = open(args[0], 'r')
else :
  infile = sys.stdin
if len(args) > 1 :
  outfile = open(args[1], 'w')
else :
  outfile = sys.stdout




################
## Main program.
################

# Instantiate and parse the transsys program.
transsysProgram  = transsys.TranssysProgramParser(infile).parse()
# Close the input file.
if infile is not sys.stdin :
  infile.close()

# Instantiate the lattice of transsys programs class.
tpl = TranssysProgramLattice(transsysProgram, latticeSize)

# Check the transsys program for acceptable diffusibility parameters.
# Diffusibility ought to be a number between 0 and 1 [0, 1] to be accepted by
# the update function.
for i in transsysProgram.factor_list :
  if float(i.diffusibility_expression.value) <= 1.0 :
    continue
  else :
    raise StandardError, 'Diffusibility expression error, please check the transsys program, the latticeSimulator works only with floating point numbers between 0 and 1'

# Instantiate the image class.
figure = LatticeFigure(tpl, maxConcentration)


############################
# Main part of the simulator
############################

#tpl.update_function(interactionPercentage, 1, randomSeed)

#for i in xrange(len(tpl.lattice)) :
#  for j in xrange(len(tpl.lattice)) :
#    outfile.write(repr(tpl.lattice[i][j].factor_concentration))
#  outfile.write()


# Use the os module to make a directory with all the images of timesteps.
# First check for the existance of the directory.
if os.path.exists(transsysProgram.name) :
  shutil.rmtree(transsysProgram.name)
# Make a directory named from the transsys program name, and change to it.
os.mkdir(transsysProgram.name)
os.chdir(transsysProgram.name)

# Introduce the signal by specifing a factor and the desired concentration.
if signalF :
  tpl.introduce_signal(xFactorConcentration, xFactorName)

## Initialize the factor concentrations in the lattice. Random or not.
# Instantiate the random object.
if homogenise == 'OFF' :
  rng = UniformRNG(randomSeed)
  tpl.randomize_lattice(rng, border_range)
else :
  rng = ConstantRNG(randomSeed)
  tpl.randomize_lattice(rng, homogenise) # Might be usefull....


## The update calculations.
# Print the header of the table file.
if printFormat in ('ALL', 'factor_table') :
  tpl.write_table_header(outfile)
statList = [] # The statistics list.
for i in xrange(noTimesteps + 1) :
  # Introduce the signal in the signal Timestep.
  if signalT :
    if i == (signalTimestep):
      tpl.introduce_signal(signalConcentration)

  # Calculate the statistics.
  statList.append(tpl.statistics())

  # Write the table to outfile.
  if printFormat in ('ALL', 'factor_table') :
    tpl.write_table(outfile)

  # Open the graphics file.
  filename = '%04d' % (i + 1) + '.pgm'
  figureFile = open(filename, 'w')

  # Produce the raster graphics files.
  s = figure.produce_row_format(tpl, maxConcentration)
  figureFile.write(s)
  figureFile.close()

  # Calculate the new lattice instance.
  tpl.update_function(i, randomSeed)


## Image file conversion and animation.
if animate :
  # Convert the images to a more readable format.
  for imageFile in os.listdir('./') :
#    os.system('cp ' + str(imageFile) + ' ' + str(imageFile) + '_OLD')
    os.system('convert -sample 320x320 ' + str(imageFile) + ' ' + str(imageFile) + '.CONV')
  # Animate.
  delaytime = 100.0 / 3.0
  os.system('animate -delay ' + str(delaytime) + ' *.pgm.CONV &')

# Return to the current directory.
os.chdir(os.pardir)


## Print the results of statistics to an .R compatible file.
# Print the header of the file.
if printFormat in ('ALL', 'statistics') :
  outfile.write('# Statistics file for testing and further analysis (Header).\n')
  outfile.write('timestep:\tfactor:\taverage:\tstddev:\tentropy:\n')
  for i, stat in enumerate(statList) :
    for f in stat.transsys_program.factor_list :
      outfile.write('%i\t%s\t%f\t%e\t%e\n' % (i, f.name, stat.average[stat.transsys_program.find_factor_index(f.name)], stat.standard_deviation[stat.transsys_program.find_factor_index(f.name)], stat.shannon_entropy[stat.transsys_program.find_factor_index(f.name)]))


# Close the output file.
if outfile is not sys.stdout :
  outfile.close()

sys.exit()
