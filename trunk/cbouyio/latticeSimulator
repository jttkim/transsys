#!/usr/bin/env python

# latticeSimulator: A program that simulates a lattice of trannsys instances
# on a nxn lattice, each cell of the lattice cantains one transsys program.
# The program applies communication between neighbour cells and is an attempt
# to simulate the processes described in "Soile V. E. Keranen, 2004. Simulation
# study on effects of signaling network structure on the developmental
# increase in complexity."
# Start developing by CBouyio on Aprill 2006 at UEA


import getopt
import sys
import copy
import random
import math
import os
import os.path
import shutil
import re

import transsys


def usage() :
  print """Usage:
./latticeSimulator [options] arguments
  Options:
  -h, --help:               Prints this screen.
          -a: switch        Animation switch. Pops a window with a graphical
                            animation of the lattice, in greyscale.
                            (Default: None)
          -b: Float         The range (0, -b) of the borders of a uniform
                            distribution, recomended to be in the [0, 1].
                            (Default: 0.25)
          -n: NumberxNumber The size of the nxm lattice.
                            (Default: 5x5)
                            *Please be very precise on the input format, there
                            should be an 'x' separating the two numbers. Any
                            other characters are not accepted.
          -t: Integer       The number of the timesteps for the simulation.
                            (Default: 30)
          -r: Integer       The rundom number generator seed.
                            (Default: 1)
          -m: Float         A maximum value of factor concentration that can
                            be represented to the image output. The image color
                            range is 0-256 gradients of grey.
                            (Deafult: 20)
          -u: switch        Homogenisation switch. Assigns to all factor
                            concentrations a constant value (related to the
                            range (-b option)).
                            (Default: Nane)
          -s: String:Number Signal switcher, (FactorName:FactorConcentration)
                            if it is defined, a factor gets the defined
                            concentration (signal) in the beginning of the
                            simulation.
                            (Default: None)
                            *WARNING, Please be very precise on the input
                             format, there should be a colon (:) between the
                             two variables and NO whitespaces at all.
          -x: Number:Number Signal swicher, (FactorConcentration:Timestep) in
                            this case ALL the factors will get the defined
                            concentration on the defined timestep.
                            (Default: None)
                            *WARNING, as above.
          -p: String        Choose to print between the available fornmats.
                            (Default: ALL)
                            Available formats (String):
                              statistics: Print the statistics of the transsys
                                          instance collection.
                            factor_table: Print the table of the factor
                                          concentrations with the relative
                                          timestep and the coordinates of the
                                          instance on the spatial model.
                                     ALL: Print both statistics and
                                          factor_table.
                                          (Default)

  Arguments:
     <infile>: A valid transsys program file. (.tra)
    <outfile>: The output file, the printout.

    *Both arguments are optional as the program is able to read/write from the
     STDIN/STDOUT in case of one/two arguments are ommited.
"""


class GaussianRNG :
  """Generates a Gaussian random object.
By calling the random_gauss method, produces a "random" number out of a Gauss
distribution
  """

  def __init__(self, rndseed, mu, sigma) :
    self.rng   = random.Random(rndseed)
    self.mu    = mu
    self.sigma = sigma

  def random_value(self) :
    return self.rng.gauss(self.mu, self.sigma)


class UniformRNG :
  """Generates a random object out of a Uniform distribution.
  """

  def __init__(self, rndseed) :
    self.rng = random.Random(rndseed)

  def random_value(self, a, b) :
    return self.rng.uniform(a, b)


class ConstantRNG :
  """Generates a "random" object of constant values!
  """

# A "random" series of "1" will be produced!
  def __init__(self, constValue) :
    self.constValue = constValue

  def random_value(self) :
    return self.constValue



class TranssysInstanceCoordinates(transsys.TranssysInstance) :
  """Subclass of TranssyInstance, contains the coordinates of the instance on
the lattice.
  """

  def __init__(self, tp, coords=None, timestep=None) :
#    transsys.TranssysInstance.__init__(self, tp, timestep)
   # No need to call the old constructor, fc_stddev and fc_entropy are
   # obsolate in this context they have been implemented in the statistics
   # object.
    self.transsys_program = tp
    self.timestep = timestep
    self.factor_concentration = [0.0] * self.transsys_program.num_factors()
#   factor_concentration
    self.coordinates = []

  def time_series(self, num_timesteps) :
    """Overrides time_series and produces a timeseries with
  TranssysInstanceCoordinates instances."""
    timeseries = transsys.TranssysInstance.time_series(self, num_timesteps)
    # This list contains the timeseries with the coordinates.
    tsCoordinates = []
    for t in timeseries:
      a = TranssysInstanceCoordinates(t.transsys_program, t.timestep)
      a.transsys_program = t.transsys_program
      a.timestep = t.timestep
      a.factor_concentration = t.factor_concentration
     # No need to override these the new class doesn't need them, check
     # comments at the constructor of the class as well.
#      a.factor_concentration_stddev = t.factor_concentration_stddev
#      a.factor_concentration_entropy = t.factor_concentration_entropy
      a.coordinates = self.coordinates
      tsCoordinates.append(a)
    return tsCoordinates


class TranssysProgramLattice(transsys.TranssysInstanceCollection) :
  """The main class of the simulator, contains a lattice of transsys programs.
The main object of the simulation, is a subclass of the
TranssysInstanceCollection class of the transsys.py module.
The lattice is in a two dimensional toroidal form.
  """

  def __init__(self, tp, size) :
    """Constructor of the class."""
    # The name of the lattice.
    self.name = tp.name + '_on_a_toroidal_two_dimentional_' + str(size[0]) + 'x' + str(size[1]) + '_lattice'
    self.lattice = self.lattice_generator(tp, size)
    self.transsysProgram = tp
    self.size = size
    # Safeguard for acceptable diffusibility parameters.
    # Diffusibility ought to be a number between 0 and 1 [0, 1] to be accepted
    # by the update function.
    for factor in self.transsysProgram.factor_list :
      if 0.0 <= float(factor.diffusibility_expression.value) <= 1.0 :
        continue
      else :
        raise StandardError, 'Diffusibility expression error. Mind that latticeSimulator accepts diffusibility values within the range of 0.0 to 1.0 [0.0, 1.0]'

#    self.factorConcentrations = self.generate_factor_concentrations_lattice()


  def lattice_generator(self, tp, size) :
    """Generates the lattice of transsys instances."""
    lattice = []
    for i in xrange(size[0]) :
      lattice.append([])
      for j in xrange(size[1]) :
        lattice[i].append(TranssysInstanceCoordinates(tp))
        lattice[i][j].coordinates.append(i + 1)
        lattice[i][j].coordinates.append(j + 1)
        lattice[i][j].timestep = 0
    return lattice


  def randomise_factor(self, fc, rng, rangeb) :
    """Returns a factor concentration out of a uniform distribution.
  Chackes for zero factor concentration and adapt the output.
  Also retarns a constant value in case of the homogenisation is set.
  """
    if not homogenise :
      if fc != 0 :
        fc = rng.random_value((fc - fc * rangeb), (fc + fc * rangeb)) # This is a way to make sure that after a perturbation the factor concentration will remain positive.
      else :
        fc = rng.random_value(0, rangeb)
    else : # Populates the matrix with a "random" constant number
      fc = rng.random_value()
    return fc


  def randomize_lattice (self, rng, rangeb) :
    """Randomize the factor concentrations of the lattice."""
#    k = self.transsysProgram.find_factor_index('Activator')
    for i in xrange(self.size[0]) :
      for j in xrange(self.size[1]) :
#        self.lattice[i][j].factor_concentration[k] = self.random_uniform_factor(self.lattice[i][j].factor_concentration[k], rng, rangeb)
        self.lattice[i][j].factor_concentration = map(lambda fc: self.randomise_factor(fc, rng, rangeb), self.lattice[i][j].factor_concentration)


  def initialise_lattice_concentrations (self, homogenise, borderRange) :
    """Initiallise the factor concentrations on the lattice."""
    if not homogenise :
      rng = UniformRNG(randomSeed)
      self.randomize_lattice(rng, borderRange)
    else :
      rng = ConstantRNG(borderRange * math.e)
      # Maybe is usefull (gives an homogenized matrix).
      self.randomize_lattice(rng, None)


#  def generate_factor_concentrations_lattice(self) :
#    """Generates a list of lists with the factor concentrations.
#Kept for legacy reasons this function is not used anymore."""
#    factorConcentrationsLattice = []
#    for i in xrange(len(self.lattice)) :
#      factorConcentrationsLattice.append([])
#      for j in xrange(len(self.lattice[i])) :
#        factorConcentrationsLattice[i].append(self.lattice[i][j].factor_concentration)
#    return factorConcentrationsLattice


  def get_transsys_program(self) :
    """Overrides the get_transsys_program method of the superclass."""
    return self.transsysProgram


  def transsys_instance_list(self) :
    """Overrides the transsys_instance_list method of the superclass."""
    ti_list = []
    for i in xrange(len(self.lattice)) :
      for j in xrange(len(self.lattice[i])) :
        ti_list.append(self.lattice[i][j])
    return ti_list


  def write_table_header(self, f) :
    """Overrides the write_table_header method of the superclass."""
    f.write('# Table of coordinated (i,j) factor concentrations (Header)\n')
    f.write('timestep i j')
    for factor in self.transsysProgram.factor_list :
      f.write(' %s' % factor.name)
    f.write('\n')


  def write_table(self, f) :
    """Overrides the write_table method of the superclass."""
    for ti in self.transsys_instance_list() :
      if ti.timestep is None :
        f.write('NA')
      else :
        f.write('%i' % ti.timestep)
      f.write(' %i %i' % (ti.coordinates[0], ti.coordinates[1]))
      for fc in ti.factor_concentration :
        f.write(' %1.17e' % fc)
      f.write('\n')


  def update_factor_concentrations(self, currentState, size, rndseed) :
    """The update function of the simulator, calculates the instances of the
  next timestep.
  Careful usage of the factor concentrations...
    """
    # Calculate the updated factor concentrations.
    # All the instances in the lattice are interacting with the 4 neighbour
    # cells, the instances in the edges are interacting with the opposite
    # cells forming the toroidal.
    # First assign the dimensions of the lattice.
    x = size[0]
    y = size[1]
    latticeFactorConcentrations = []
    # Include some noise or not.
#    rng = GaussianRNG(rndseed, 0, 0.1)
    rng = ConstantRNG(0)
    for i in xrange(len(self.lattice)) :
      latticeFactorConcentrations.append([])
      for j in xrange(len(self.lattice[i])) :
        # The factor concentrations manipulation.
        factorConcentrationsUpdate = [0.0] * self.transsysProgram.num_factors()
        # Get the current lattice concentrations.
        factorConcentrationsOld = currentState[i][j].factor_concentration
        if len(factorConcentrationsOld) != len(factorConcentrationsUpdate) :
          raise StandardError, 'Factor number inconsistancy between the new and the old factor concentrations list.'
        for k in xrange(len(factorConcentrationsUpdate)) :
          # The main calculation of the new factor concentrations.
          # Introduce "per factor" diffusibility expression.
          p = self.transsysProgram.factor_list[k].diffusibility_expression.value
          # Check the toroidal transformations by using the modulo division!
          fc = (factorConcentrationsOld[k] + (rng.random_value() + (p * self.lattice[(x + i - 1) % x][j].factor_concentration[k])) + (rng.random_value() + (p * self.lattice[i][(y + j - 1) % y].factor_concentration[k])) + (rng.random_value() + (p * self.lattice[i][(j + 1) % y].factor_concentration[k])) + (rng.random_value() + (p * self.lattice[(i + 1) % x][j].factor_concentration[k]))) / (4 * p + 1)
          factorConcentrationsUpdate[k] = fc
        latticeFactorConcentrations[i].append(factorConcentrationsUpdate)
    return latticeFactorConcentrations


  def update_function(self, timesteps, rndseed) :
    """Calculates the new transsys instance."""
#    for n in xrange(timesteps) :
    # Produce a copy of the current state of the simulator.
    currentState = self.lattice ## Kludge
    updateFactorConcentrations = self.update_factor_concentrations(currentState, self.size, rndseed)
    for i in xrange(len(self.lattice)) :
      for j in xrange(len(self.lattice[i])) :
        if len(self.lattice[i][j].factor_concentration) != len(updateFactorConcentrations[i][j]) :
          raise StandardError, 'update_function Error. Factor number inconsistancy'
        else :
          self.lattice[i][j].factor_concentration = updateFactorConcentrations[i][j]
          # The timeseries doesn't work with timestep 1, returns zero.
          # Thats why a timestep = 2 is used.
          # FIXME: The number of timesteps of each transsys instance on the
          # lattice timeseries is awlays one because of the usage of timestep
          # one all the time. Update it, to take the number of the current
          # timestep.
          self.lattice[i][j] = self.lattice[i][j].time_series(2)[1]
          self.lattice[i][j].timestep = (timesteps + 1)


  def signal_factor_concentration(self, xCenter, yCenter, signal, factor) :
    """Sets the factor concentration to signal."""
    for i in xCenter :
      for j in yCenter :
        if factor == None :
          self.lattice[i][j].factor_concentration = [signal for fc in self.lattice[i][j].factor_concentration]
        elif factor:
          k = self.transsysProgram.find_factor_index(factor)
          self.lattice[i][j].factor_concentration[k] = signal


  def introduce_signal(self, signalC, xFactor = None) :
    """Sets a specific factor concentration to the declared value, or sets all
  the factor conscentrations of the speciffic timestep to the declared value.
    """
    # Check for the existance of the xFactor.
    if xFactor != None :
      if not xFactor in self.transsysProgram.factor_names() :
        raise StandardError, 'Factor %s is not a valid %s factor name. Please specify a valid factor name.' % (xFactor, self.transsysProgram.name)
    # Find the center of the lattice.
    # If abscissa is odd number.
    if divmod(self.size[0], 2)[1] == 1 :
      i = [divmod(self.size[0], 2)[0]]
    # If abscissa is even number.
    elif divmod(self.size[0], 2)[1] == 0 :
      q = divmod(self.size[0], 2)[0]
      i = range(q - 1, q + 1)
    # If ordinate is odd.
    if divmod(self.size[1], 2)[1] == 1 :
      j = [divmod(self.size[1], 2)[0]]
    # If ordinate is even.
    elif divmod(self.size[1], 2)[1] == 0 :
      q = divmod(self.size[1], 2)[0]
      j = range(q - 1, q + 1)
    # Call the signal_factor_concentration function.
    self.signal_factor_concentration(i, j, signalC, xFactor)
    #######
    # Alternatively, set a randomly choosen factor concentration.
#    k = random.randint(0, (self.ranssysProgram.num_factors() - 1))
#    self.lattice[i][j].factor_concentration[k] = random.gauss(signalC, 1)
#     # Randomize factor concentrations NOT USED anymore.
#     k = random.randint(0, (self.transsysProgram.num_factors() - 1))
      # Alternatively, set a randomly choosen factor concentration.
#      k = random.randint(0, (self.transsysProgram.num_factors() - 1))
#      self.lattice[i][j].factor_concentration[k] = random.gauss(signalC, 1)


class LatticeFigure :
  """This class contains an imagefile (in raw image .pgm format) of a transsys
lattice.
  """

  def __init__(self, transsysLattice, cd) :
    self.figure = self.produce_row_format(transsysLattice, cd)


  # Function kept for lecgacy reasons after the introduction of the user defined
  # maximum accepted factor concentration value, there is no need for this
  # anymore.
  def flatten_lattice(self, factorConcentrationsLattice) :
    """Flattens the factor concentration lattice to a single list.
  Kept for legacy reasons, this function is not called anymore.
    """
    flatfactorConcentrations = []
    for i in xrange(len(factorConcentrationsLattice)) :
      for j in xrange(len(factorConcentrationsLattice[i])) :
        for fc in factorConcentrationsLattice[i][j] :
          flatfactorConcentrations.append(fc)
    return flatfactorConcentrations


  def produce_row_format(self, transsysLattice, maxC) :
   """Produces a Netpbm raster image file.
  Suitable for view/analyse with the Imagemagick graphics package.
   """
   # Generate the apropriate .pgm image format.
   pgmMagic = 'P2' # .pgm file magic line, P2 for .pgm,
   pgmComment = '# ' + transsysLattice.name + ' .pgm image of ' + ' timestep'
   pgmSize = str(transsysLattice.size[0]) + ' ' + str(transsysLattice.size[1])
   pgmMaxval = 256
   pgmRaster = ''
   # Code kept for legacy reasons, after the introduction of the user defined
   # maximum accepted factor concentration for the image gradient, this rather
   # strange approach has been replaced by a more resonable one.
   # All this approach has been substitute with a simplier way to deal with the color range of the images. Check the next code chunks.
#   flattenFCL = self.flatten_lattice(transsysLattice.generate_factor_concentrations_lattice())
#   maxValue = math.ceil(max(flattenFCL))
#   # Not so nice trick to avoid division by zero later.
#   if maxValue == 0.0 :
#     maxValue = 1e-99
   for i in xrange(transsysLattice.size[0]) :
     pgmRasterLine = ''
     for j in xrange(transsysLattice.size[1]) :
#       # Calibration within the color interval.
#       # The calibration procesure has been simplified now and a user defined
#       # maximum printing factor concentration has been introduced, Keeping
#       # this code for legacy reasons..
#       p = pgmMaxval - int(math.floor(((sum(transsysLattice.lattice[i][j].factor_concentration)) / (len(transsysLattice.lattice[i][j].factor_concentration) * maxValue) * pgmMaxval)))
       # The new simplified way to deal with the color gradients versus factor
       # concentrations.
       #FIXME: this should simplified more and produce one image file for EACH
       # factor at more complicated transsys programs.
       p = pgmMaxval - int(round(sum(transsysLattice.lattice[i][j].factor_concentration) * pgmMaxval / maxC))
       if p < 0 :
         raise StandardError, 'Netpbm raster image get a negative value. Please select a biger number for the maximum factor concentration (option -m)'
       pgmRasterLine = pgmRasterLine + str(p) + ' '
     pgmRaster = pgmRaster + pgmRasterLine + '\n'
   pgmText = pgmMagic + '\n' + pgmComment + '\n' + pgmSize + '\n' + str(pgmMaxval)  + '\n' + pgmRaster
   return pgmText


def osManipulation(tpname) :
  """Function to conduct the file and the out data storage directory manipulation."""
  # First check for the existance of the directory.
  if os.path.exists(tpname) :
    shutil.rmtree(tpname)
  # Make a directory named from the transsys program name, and change to it.
  os.mkdir(tpname)
  os.chdir(tpname)


def printing(statList, printf) :
  """Manipulates the different printouts."""
#  if printf in ('ALL', 'factor_table') :
#    pass
  if printf in ('ALL', 'statistics') :
    outfile.write('# Statistics file for testing and further analysis (Header).\n')
    outfile.write('timestep:\tfactor:\taverage:\tstddev:\tentropy:\n')
    for i, stat in enumerate(statList) :
      for f in stat.transsys_program.factor_list :
        outfile.write('%i\t%s\t%f\t%e\t%e\n' % (i, f.name, stat.average[stat.transsys_program.find_factor_index(f.name)], stat.standard_deviation[stat.transsys_program.find_factor_index(f.name)], stat.shannon_entropy[stat.transsys_program.find_factor_index(f.name)]))
  if printf in ('NO', None) :
    pass


def run_simulator(timesteps, printf) :
  """Function which integrates all the necesary calculations for the simulator run cycles."""
  # Print the header of the table file.
  if printf in ('ALL', 'factor_table') :
    tpl.write_table_header(outfile)
  statList = [] # The statistics list.
  factorTable = []
  for i in xrange(timesteps + 1) :
    # Introduce the signal in the signal Timestep.
    if signalTimestep :
      if i == (tTimestep):
        tpl.introduce_signal(tConcentration)

    # Calculate the statistics.
    statList.append(tpl.statistics())

    # Write the table to outfile.
    if printf in ('ALL', 'factor_table') :
      tpl.write_table(outfile)

    # Open the graphics file.
    filename = transsysProgram.name + '_t%04d' % (i + 1) + '.pgm'
    figureFile = open(filename, 'w')

    # Produce the raster graphics files.
    s = figure.produce_row_format(tpl, maxConcentration)
    figureFile.write(s)
    figureFile.close()

    # Calculate the new lattice instance.
    tpl.update_function(i, randomSeed)

  # Prints the statistics.
  printing(statList, printf)


def animation() :
  """Produces the animated movie of the simulator."""
  # Convert the images to a more readable size and produce the movie file.
  os.system('convert -sample 480x480 -delay 35 *.pgm ' + transsysProgram.name + 'Movie.mng')
  # Animate.
  os.system('animate *.mng &')
  # Return to the current directory.
  os.chdir(os.pardir)



####### Simulator's Parameter Initialization #################################
latticeSize      = [5, 5] # The dimensions of the lattice.
noTimesteps      = 30     # The running timesteps of the simulation.
randomSeed       = 1      # The seed for the random number generators.
maxConcentration = 20     # The maximum concentration that can be drawn.
signalTimestep   = False  # The 'signal on a timestep', introduction switch.
signalFactor     = False  # The 'signal of a factor', introduction switch.
animate          = False  # The animation switch.
printFormat      = 'ALL'  # The default printing format.
border_range     = 0.25   # The border range (%) of the uniform distribution.
homogenise       = False  # The homogenisation switch.


## Command line parsing.
try :
  optlist, args = getopt.getopt(sys.argv[1:], 'a b: h m: n: p: r: s: t: u x:', ['help'])
except getopt.GetoptError, errorMessage :
  errorMessage = 'Error in arguments parsing, please give -h or --help for help '
  print errorMessage
  sys.exit(1)

for opt, par in optlist :
  if opt in ('-h', '--help') :
    usage()
    sys.exit()
  if opt in ('-n') :
    x = re.compile('x')
    if x.search(par) :
      latticeSize = x.split(par)
      latticeSize = map(lambda x:int(x), latticeSize)
    else :
      raise TypeError, 'Error in the format of -n input options, please check the help (-h, --help) for more information'
  if opt in ('-t') :
    noTimesteps = int(par)
  if opt in ('-r') :
    if par == 'None' :
      randomSeed = None
    else :
      if float(par) :
        randomSeed = float(par)
  if opt in ('-m') :
    maxConcentration = float(par)
  if opt in ('-x') :
    var = par.split(':')
    if len(var) != 2 :
      raise TypeError, 'Error in the format of -x input options, please check the help (-h, --help) for more information.'
    if float(var[0]) :
    # No need to raise an exeption Python will raise one for you!!!
#      raise TypeError, 'Please give a valid floating point representation for the concentration parameter, Check help (--help) for more information.'
      signalTimestep = True
      tConcentration = float(var[0])
      tTimestep = int(var[1])
  if opt in ('-s') :
    var = par.split(':')
    if len(var) != 2 :
      raise TypeError, 'Error in the format of -s input options, please check the help (-h, --help) for more information.'
    if float(var[1]) :
      signalFactor = True
      sFactorName = var[0]
      sFactorConcentration = float(var[1])
  if opt in ('-a') :
    animate = True
  if opt in ('-p') :
    printFormat = par
    if printFormat not in ('ALL', 'statistics', 'factor_table', 'NO') :
      raise StandardError, 'Error in the -p input options, invalid printing format. Please check the help (-h, --help) for more information.'
  if opt in ('-b') :
    border_range = float(par)
  if opt in ('-u') :
    homogenise = True

#print optilist


## I/O manipulation.
if len(args) > 0 :
  infile = open(args[0], 'r')
else :
  infile = sys.stdin
if len(args) > 1 :
  outfile = open(args[1], 'w')
else :
  outfile = sys.stdout



################
## Main program.
################

# Instantiate and parse the transsys program.
transsysProgram  = transsys.TranssysProgramParser(infile).parse()
# Close the input file.
if infile is not sys.stdin :
  infile.close()

# Instantiate the lattice of transsys programs class.
tpl = TranssysProgramLattice(transsysProgram, latticeSize)

# Instantiate the image class.
figure = LatticeFigure(tpl, maxConcentration)


############################
# Main part of the simulator
############################

# Use the os module to make a directory where all the image files will be
# stored.
osManipulation(transsysProgram.name)

# Introduce a signal by specifing a factor and the desired concentration.
if signalFactor :
  tpl.introduce_signal(sFactorConcentration, sFactorName)

# Initialise the factor concentrations on the lattice. Homogenus or not.
tpl.initialise_lattice_concentrations(homogenise, border_range)

# Run the simulator.
run_simulator(noTimesteps, printFormat)

# Image file conversion and animation.
if animate :
  animation()

# Close output file and exit.
if outfile is not sys.stdout :
  outfile.close()

sys.exit()
