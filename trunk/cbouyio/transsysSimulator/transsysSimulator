#!/usr/bin/env python

# $Rev:: 237           $:  Revision of last commit
# $Author:: cbouyio    $:  Author of last commit
# $Date: 2006-12-04 22:51:36 +0000 (Mon, 04 Dec 2006) $:  Date of last commit

# $Id$ 

"""transsysSimulator: Conduct several simulation experiments and calculations
on transsys programs and print out the results in various formats.

One of the first scripts... Major revision/refactoring on November 2006. Huge
amount of comments follows...)))
"""

# $Log: transsys_simulator,v $
# Revision 1.5  2005/12/22 15:34:33  konsb
# Fixed the initialization of the MultiFactorConcentrations list
#
# Revision 1.4  2005/12/06 19:46:12  konsb
# add the Id and Log

# transsys_simulator   The first CVS version of the transsys project.
# New name and some minor style fixes.
# CBouyio, UEA, 02/12/2005.

# Update on Transformed version.
# Introduce the equilibration and initialization functions.
# Give some more meaningfull names in some variables.
# CBouyio, UEA, 01/12/2005.
# The Transformed version has been developed to make the output suitable for
# SVD-PCA analysis for both the timeseries and the final state of transsys 
# programs, thats why it introduces the different printout formats.
# CBouyio, UEA, 22/11/2005.

# Third version: transsys_distances_r_03
# Minor changes on 10/11/2005 (r-03):
# Improved floating point presision at the output data, (1.12e representation).
# Fixes on the printing functions.
# A better build of the RNG stuff, every time call a generic method 
# called randomValue()
# Changes on 09/11/2005 (r_03):
# Minor changes (more meaningful names for the controlparameters).
# Implements a random object, to genatrate the random numbers string.
# Change the perturbation method implementation, working with a rng object 
# (Random Number Genarator) a object of the class GaussianRNG.
# Introduce a new control parameter, the number of different perturbed 
# states (no_perturbeSamples).
# Improovments in the Usage() output.
# Introduce the printout() function, to explain the printout format. 
# Changes on 07/11/2005 (r_02):
# Prints out in a more consistent format (using headers for R files). 
# DOESN'T print in ; separated anymore. (r_02)
# Compute the "random" state of a transsys instance, instead of a random 
# factor concentration list, the elements of the new list will be calculated 
# according to a "random" distribution (check the random module of python for 
# more details). Take extra care of the way to build such bistribution.
# Implementation: 'factor_concentration_pertubation' method (r_02)
# Doesn't get as the initial state the transsys instance of zero but let the 
# program run several times and then get an instance. (r_02)
# Changes on 28/10/2005 (r_01):
# Minor changes: Prints in ";" separated columns (R readable format). (r_01)
# Contains a constant random seed to increase reproducibility !
# should change in upcoming versions. (r_01)
# Implements a function for randomize the factor concentration list. (r_00)
# CBouyio & JTK, UEA, 28 Oct 2005.

# Indicate the program version
__version__ = "$Id$"

import copy
import random
import getopt
import math
import sys
import time

#import transsys.utils
import transsys


def usage():
  print """Usage:
./transsysSmulator [options] arguments
  Options:
            -d: Integer       Sampling intervals (default=1).
            -e: Switch        Equilibration procedure switcher, enables the
                              equilibration function, leads the system to an
                              equilibrium before starting any other procedure.
    -h, --help: Switch        Prints this screen and exit.
            -i: Number:Number Initialize the factor concentration of a transsys
                Number-Number program. (-) Uniform with Lower-Upper. (:) Gauss
                Number        with Mean:standard_deviation. Or Constant Number
            -m: Integer       Number of perturbed samples.
            -t: Integer       Number of timesteps. (Compulsory parameter)

################# THIS WILL BE CHANGED #########################
            -p: The printout format: (default = normal)
              normal      : Prints out in a timestepsXdistances format.
              final_state : Prints out in a factorXconcentration format.
                            Considers only the final state of the simulation.
                            (suitable for SVD/PCA analysis)
              factors     : Prints out in a timestepsXfactor_concentration
                            format. (Suitable for SVD/PCA analysis)
              factors_SVD : Prints out in a timestepXfactor_concentration
                            format, only the factor concentrations of the
                            perturbed state. Works ONLY if -m=1
                            (Suitable for the SVD-PCA analysis of the various
                            network classes)
######################################################################

             -r: Integer      Random Seed of the Random Number Generator.
                              (default=1)
             -n: Char:Number  Introduction of noise on a perturbation.
                              Char (U or G) defines type of the noise
                              distribution (Uniform or Gauss) and number is the
                              lower-upper interval in the Uniform or the sigma
                              in the Gauss case.

  Arguments:
     input_file: A transsys program file.
    output file: The printout file. (--printhelp to get more information
                 regarding the format of the output files)
  *The program reads from the <STDIN> and writes to <STDOUT> in case of input
   and/or output files are not specified respectively.
   """



class GaussianRNG(object):
  """Constructs a random object out of a Gaussian distribution.

  By calling the random_gauss method produce a "random" number out of a Gauss
  distribution
  """
  def __init__(self, rndseed, mu, sigma):
    if not isinstance(rndseed, int):
      raise StandardError, 'The random number generator accepts only integer seeds.'
    self.rng   = random.Random(rndseed)
    self.mu    = mu
    self.sigma = sigma

  def __str__(self):
    return "Gaussian"

  def random_value(self):
    """Common method among all xxxxRNG classes.

    Use the rndom.gauss python builtin function."""
    return self.rng.gauss(self.mu, self.sigma)



class UniformRNG(object):
  """Class of random objects out of a Uniform distribution.

  By calling the random.uniform method, produces a "random" number out of a
  Uniform distribution.
  """
  def __init__(self, rndseed, lower=None, upper=None):
    """Constructor of the class.

    note the "duall" behaviour of the constructor.
    """
    if not isinstance(rndseed, int):
      raise StandardError, 'The random number generator accepts only integer seed.'
    self.rng = random.Random(rndseed)
    self.lower = lower
    self.upper = upper

  def __str__(self):
    return "Uniform"

  def random_value(self, lower=None, upper=None):
    """Common method among all xxxxRNG classes.

    Note again the "duall" functionality of this method. If it is called
    4without any parameters is getting the class member variables, or the user
    specified elsewhere.
    """
    if (lower is None) and (upper is None):
      if (self.lower is None) or (self.upper is None):
        # FIXME this "duall" functionality should refactored one day...
        raise StandardError, "Lower and/or Upper boundaries for the Uniform Distr. missing Please carefull with the call and/or the constructor of this object. A bit akward..."
      else:
        return self.rng.uniform(self.lower, self.upper)
    else:
      return self.rng.uniform(lower, upper)



class ConstantRNG(object):
  """Return a constant "random" number."""
  # Dont take it serious just for fun a random "1" will be produced...)))
  def __init__(self, constValue):
    self.constValue = constValue

  def __str__(self):
    return "Constant"

  def random_value(self):
    """Common method among all xxxxRNG classes."""
    return self.constValue



# derive a subclass of transsys.TranssysInstance which has an additional
# method called euclidean_distance, which takes another instance of
# transsys.TranssysInstance as a parameter and returns the Euclidean
# Distance.

# This "advanced" overrides the time_series method of the superclass.

class TranssysInstanceAdvanced(transsys.TranssysInstance):
  """Subclass of TranssysInstance with some "advanced" attributes.

    Calculates the Euclidian distance between two Transsys Instances
    and randomize or make the perturbation of the factor concentration
    list elements.
    """
  def __init__(self, tp, timestep=None):
    transsys.TranssysInstance.__init__(self, tp, timestep)
    self.perturbationNumber = 0


  def time_series(self, num_timesteps, sampling_period = 1, lsys_lines = None, lsys_symbol = None):
    """Produces a timeseries with TranssysInstanceAdvanced instances.

    Overrides the superclass method.
    """
    timeseries = transsys.TranssysInstance.time_series(self, num_timesteps, sampling_period, lsys_lines, lsys_symbol)
    tsAdvanced = []
    # Constructs a TranssysInstanceEuclidianDistance Instance of the 
    # timeserieslist. The timeseries has now instances from 
    # TranssysInstanceEuclidianDistance class.
    for t in timeseries:
      a = TranssysInstanceAdvanced(t.transsys_program, t.timestep)
      a.transsys_program = t.transsys_program
      a.timestep = t.timestep
      a.factor_concentration = t.factor_concentration
      a.factor_concentration_stddev = t.factor_concentration_stddev
      a.factor_concentration_entropy = t.factor_concentration_entropy
      tsAdvanced.append(a)
    return tsAdvanced


  # function to compute the Euclidean distance between the factor
  # concentration vectors in two TranssysInstance objects
  # (1) should work for transsys instances with any number of factors
  # (2) should properly handle the case of being passed transsys instances
  # of different transsys programs (domain restricted to "legal" input of
  # instances of same transsys program.

  def euclidean_distance_instances(self, self2):
    """Returns the Euclidean distance between two Transsys instances.
    """
    # Check the self2 variable... )))
#    # Check weather two timesteps are derived from the same transsys program.
#    if self.transsys_program is not self2.transsys_program :
#      raise StandardError, "Transsys Istances derived from two different transsys programs. Can not calculate Euclidian Distance."
    euclideanDistance = euclidean_distance(self.factor_concentration, self2.factor_concentration)
    return euclideanDistance


  def perturbation(self, rng, uniRange=None):
    """Pertube factor concentrations according to the specified rng.

    rng: random number generator. Introduces noise following two patterns.
    Uniform noise: Factor perturbed in a random value around a specified range
    of the factor's concentration.
    Gauss noise: A qauantity out of a Gauss(0, sigma) distribution is added to
    the factor's concentration.
    Returns: None -- method modifies instance itself.
    """
    perturbedList = []
    if rng is None :
      pass
    elif isinstance(rng, GaussianRNG):
      for fc in self.factor_concentration :
        tmp = rng.random_value()
        while tmp + fc <= 0:
          tmp = rng.random_value()
        perturbedList.append(tmp + fc)
    elif isinstance(rng, UniformRNG):
      if uniRange is None :
        raise StandardError, "The function should be called with the uniform range parameter to have the disered functionality."
      for fc in self.factor_concentration :
        if fc == 0 :
          fc = rng.random_value(0, uniRange)
        else :
          # This restricts the range of the perturbations at the positive
          # numbers only.
          fc = rng.random_value(fc - (fc / (uniRange * 100)), fc + (fc / (uniRange * 100)))
        perturbedList.append(fc)
#    self.factor_concentration = perturbedList
    return perturbedList



  def initialisation(self, initialRNG):
    """initialise the factors concentration according to the initialisation RNG."""
    if initialRNG:
      for i in xrange(len(self.factor_concentration)):
        self.factor_concentration[i] = initialRNG.random_value()
    else:
      pass

  def equilibration(self):
    """Run a timeseries on a given transsys instance untill the equilibration
    criterion will be satisfied
    """
    # First very naive attempt, The program just run a timeseries for 100
    # timesteps... Should introduce a more reasonable equilibration
    # criterion...
#    if e:
    self = self.time_series(101).pop()
#    else:
#      pass


def euclidean_distances_list(tilist):
  """Return the matrix of Euclidean distances of an instance collection.

  @rtype: C{list} of C{float}
  """
  edList = []
  for i in xrange(len(tilist)):
    for j in xrange(i + 1, len(tilist)):
      edList.append(tilist[i].euclidean_distance_instances(tilist[j]))
  return edList



def euclidean_distance(fcl1, fcl2):
  """Returns the euclidean distance between two lists-vectors."""
  # Consistancy check.
  if len(fcl1) != len(fcl2):
    raise StandardError, "Error in Euclidean distance calculation. Check the factor concentrations lists."
  edTmp = 0
  for i in xrange(len(fcl1)):
    edTmp += (fcl1[i] - fcl2[i]) ** 2
  euDist = math.sqrt(edTmp)
  return euDist


def mean(a_list):
  """Return the mean of a numeric list."""
  meanValue = sum(a_list) / len(a_list)
  return meanValue


def print_comments(fileObj):
  """Print the header of the output file."""
  fileObj.write("# Script       : %s\n# Time         : %s\n# Input File   : %s\n# Outpout File : %s\n# Simulator's Control Parameters:\n# Number of Timesteps     (-t):%i\n# Sampling Intervals      (-d):%i\n# Equilibration           (-e):%s\n# Initial Concentrations  (-i):%s\n# Number of Perturbations (-m):%i\n# Random Seed             (-r):%i\n# Perturbation Function   (-n):%s\n" % (__version__, time.asctime(), infile.name, outfile.name, noTimesteps, samplingIntervals, equilibrium, initRNG.__str__(), noPerturbedSamples, rndSeed, perturbRNG, ))


def print_factor_table(fileObj, multiTS):
  """Print the factor table."""
  #first print header
  fileObj.write('timestep perturbation')
  for factor in transsysProgram.factor_list :
    fileObj.write(' %s' % factor.name)
  fileObj.write('\n')
  # Then print the whole table.
  for i in xrange(noTimesteps):
    for j in xrange(len(multiTS)):
      fileObj.write('%i %i' % (i, j))
      for fc in multiTS[j][i].factor_concentration :
        fileObj.write(' %1.17e' % fc)
      fileObj.write('\n')



#### Initialise the control parameters of the simulation.
#########################################################
noTimesteps        = 0     # Number of timesteps. (-t)
samplingIntervals  = 1     # Default number of sampling intervals. (-d)
equilibrium        = None  # Equlibration switch. (-e)
initRNG            = None  # Initialize the factor concentrations. (-i)
noPerturbedSamples = 0     # Number of perturbed instances. (-m)
rndSeed            = 1     # Random number generator seed. (-r)
perturbRNG         = None  # Control the intoduction of noise to the system.
                           # Can choose between two different types of noise
                           # U:<value> (the noise come from a uniform
                           # distribution with value% up and down from the
                           # factor concentration) or
                           # G:<value> (the noise come from a gauss distribution
                           # with zero mean and value stamdard deviation)(-n)
uniformRange       = None  # The perturbation range under the uniform
                           # distribution.
edPrintOut         = None  # A file with the print out the of Euclidean
                           # Distance list.
secondTPname       = None  # A second transsys program for comparison of.



# Command line parsing.
optlist, args = getopt.getopt(sys.argv[1:], "c:d:ehi:n:m:p:r:t:", ["help", "noise"])

# Extract the command line parameters.
for option, par in optlist :
  if option in ("-h", "--help"):
    usage()
    print __version__
    sys.exit(1)
  if option == "-t" :
    noTimesteps = int(par)
  if option == "-d" :
    samplingIntervals = int(par)
  if option == "-m" :
    noPerturbedSamples = int(par)
  if option == "-e" :
    equilibrium = True
  if option == "-r":
    rndSeed = int(par)
  if option == "-i" :
    if len(par.split(':')) == 2 :
      initRNG = GaussianRNG(rndSeed, float(par.split(':')[0]), float(par.split(':')[1]))
    elif len(par.split('-')) == 2 :
      initRNG = UniformRNG(rndSeed, float(par.split('-')[0]), float(par.split('-')[1]))
    elif float(par):
      initRNG = ConstantRNG(float(par))
    else :
      raise StandardError, "Error in initialisation parameter parsing. Check the format of the -i parameter"
  if option in ("-n", "--noise"):
    if len(par.split(":")) == 2 :
      if par.split(":")[0] == "U" :
        perturbRNG = UniformRNG(rndSeed)
        uniformRange = float(par.split(":")[1])
        if (uniformRange <= 0) or (uniformRange > 1):
          raise StandardError, "The uniform distribution range should be within the (0, 1] interval."
      elif par.split(":")[0] == "G" :
        perturbRNG = GaussianRNG(rndSeed, 0, float(par.split(":")[1]))
      else :
        raise StandardError, "Error in noise parameter parsing. Check the syntax of the -n option."
    else :
      raise StandardError, "Error in noise parameter parsing. Check the syntax of the -n option."
  if option in ('-p'):
    edPrintOut = str(par)
  if option in ('-c'):
    secondTPname = str(par)


# I/O implementation.
if len(args) > 0:
  infile = open(args[0], 'r')
else:
  infile = sys.stdin
if len(args) > 1:
  outfile = open(args[1], 'w')
else:
  outfile = sys.stdout


# Mandatory Options Checking.
if noTimesteps == 0 :
  raise StandardError, '-t option mandatory. Specify number of timesteps or give -h, --help for more information.'
# Dependent parameter checking.
if noPerturbedSamples :
  if perturbRNG is None :
    raise StandardError, "Specify a noise function for the perturbation."
if edPrintOut :
  if not secondTPname and not noPerturbedSamples :
    raise StandardError, "A second transsys program or a number of perturbed samples is needed for print out the Euclidean distance list."
  if secondTPname and noPerturbedSamples :
    raise StandardError, "The program can work with either the -c or the -m option not with both."


###############
## MAIN PROGRAM
###############

# Parse the transsys program.
transsysProgram = transsys.TranssysProgramParser(infile).parse()
# Close the infile.
if infile is not sys.stdin:
  infile.close()

# Instantiate the transsys program (Advance instance within this script).
transsysInstance = TranssysInstanceAdvanced(transsysProgram)

# Initialize the values of the factor concentrations.
if initRNG :
  transsysInstance.initialisation(initRNG)

# Equilibration Procedure. Check the documentation of the function for more.
if equilibrium :
  transsysInstance.equilibration()


# No need to perturb the state you van do it using the initialisation function.
## Perturbe the state or not.
#if perturbRNG :
#  ti.perturbation(perturbRNG, uniformRange)


# Calculate the timeseries.
ts = transsysInstance.time_series(noTimesteps, samplingIntervals)

# Initialize the list of multiple timeseries
multiTimeseries = [ts]

# If the program defines perturbations or second transsys program.
if noPerturbedSamples or secondTPname :
  # We dont want both cases to be true...
  if noPerturbedSamples and secondTPname :
    raise StandardError, "the Euclidean Distances can be calculated only for multiple perturbations or for a second transsys program not for both. Check the options of the simulator."

  # Run the simulator for (m = noPerturbedSamples) times.
  if noPerturbedSamples :
    for perturbedSample in xrange(noPerturbedSamples):
      # Create a perturbed instance:
      # First make a copy.
      perturbedInstance = copy.deepcopy(transsysInstance)

      # Give it a number.
      perturbedInstance.perturbationNumber = perturbedSample + 1

      print perturbedInstance.perturbationNumber
      # Then perturbe it (check perturbation method).
      perturbedInstance.factor_concentration = perturbedInstance.perturbation(perturbRNG, uniformRange)

      # Calculate a second time series (same length as first).
      perturbedTimeseries = perturbedInstance.time_series(noTimesteps, samplingIntervals)

      # Collect all the timeseries.
      multiTimeseries.append(perturbedTimeseries)

  elif secondTPname :
    # A second transsys program run to compare the results.
    secondTPfile = open(secondTPname, 'r')
    secondTProgram = transsys.TranssysProgramParser(secondTPfile).parse()
    secondTPinstance = TranssysInstanceAdvanced(secondTProgram)
    if equilibrium :
      secondTPinstance.equilibration()
    if initRNG :
      secondTPinstance.initialisation(initRNG)
    secondTimeseries = secondTPinstance.time_series(noTimesteps, samplingIntervals)
    multiTimeseries.append(secondTimeseries)


############## Obsolete Code.... #########################
#  # Calculate the Euclidean Distances between the corresponding timesteps
#  # of the reference and the second timeseries.
#  edl = euclidean_distance_timeseries(timeseries, secondtimeseries)
#
#  # Assign the factor concentration list of the final state 
#  # (Needed for the SVD).
#  fcl = secondtimeseries[no_Timesteps - 1].factor_concentration
#
#  # Collect all the Euclidean distances lists.
#  MultiEuDist.append(edl)
#
#  # Collect all the timeseries.
#  MultiTimeseries.append(secondtimeseries)
#
#  # Collect all the factor concentrations.
#  MultiFactorConcentrations.append(fcl)


# Euclidean Distance Calculations.
# All calculations are ebnded up with a list of Euclidean distances. Carefull
# with the differnt implementations.
euDistList = []
for i in xrange(noTimesteps):
  # This loop calculates the mean Euclidean Distance between a transsys
  # Instances collection.

  # Case of two different transsys programs.
  if secondTPname and len(multiTimeseries) == 2 :
  # Then check for the same number of factors (otherwise euclidean Distance has
  # no meaning)
    if len(multiTimeseries[0][0].factor_concentration) != len(multiTimeseries[1][0].factor_concentration):
      raise StandardError, "Transsys programs have different number of factors. Euclidean Distance Calculation is imposible."
    # then start the calculations.
    tiList = []
    for j in xrange(len(multiTimeseries)):
      # Carefull with the index exchange (multiTimeseries comes in a
      # perturbations x timesteps design)
      tiList.append(multiTimeseries[j][i])
    euDistList.append(mean(euclidean_distances_list(tiList)))

  # Case of a perturbations set.
  elif noPerturbedSamples :
    tiList = []
    meanEuDist = []
    for j in xrange(len(multiTimeseries)):
      # Carefull with the index exchange (multiTimeseries comes in a
      # perturbations x timesteps design)
      tiList.append(multiTimeseries[j][i])
    meanEuDist = mean(euclidean_distances_list(tiList))
    euDistList.append(meanEuDist)
  elif edPrintOut :
    raise StandardError, "Something is going wrong..."



# PRINTOUTS.
# Check the print functions.

# Default printout (similar with the lattice printout... )

# Print some comments first (command line parameters).
print_comments(outfile)

# Print the table.
print_factor_table(outfile, multiTimeseries)

if edPrintOut :
  edOutFile = open(edPrintOut, 'w')
  edOutFile.write('eu_dist\n')
  for euclideanDist in euDistList :
    edOutFile.write('%f\n' % euclideanDist)


# Close the files.
if infile is not sys.stdin:
  infile.close()
if outfile is not sys.stdout:
  outfile.close()

