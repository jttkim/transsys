#!/usr/bin/env python

# latticeSimulator: A program that simulates a lattice of trannsys instances
# on a nxn lattice, each cell of the lattice cantains one transsys program.
# The program applies communication between neighbour cells and is an attempt
# to simulate the processes described in "Soile V. E. Keranen, 2004. Simulation
# study on effects of signaling network structure on the developmental
# increase in complexity."
# Developed by CBouyio Aprill 2006 UEA


import getopt
import sys
import copy
import random
#import math
import os
import os.path
import shutil
import re

import transsys


def usage() :
  print """Usage:
./latticeSimulator [options] arguments
  Options:
  -h, --help:   Prints this screen.
          -a: (switch)      The animate flag, pops a window with a graphical
                            animation of the simulator.
                            (Default: OFF)
          -n: Integer       The size of the nxn lattice.
                            (Default: 5x5)
          -t: Integer       The number of the timesteps for the simulation.
                            (Default: 30)
          -r: Integer       The rundom number generator seed.
                            (Default: 1)
          -m: Float         The maximum value of factor concentration that can
                            be represented to the image output. The image color
                            range is 0-255 gradients of grey.
                            (Deafult: 10)
          -s: String:Number Signal switcher, (FactorName:FactorConcentration)
                            if it is defined, a factor gets the defined
                            concentration (signal) in the beginning of the
                            simulation.
                            (Default: None)
                            *WARNING, Please be very precise on the input
                             format, there should be a colon (:) between the
                             two variables and NO whitespaces at all.
          -x: Number:Number Signal swicher, (FactorConcentration:Timestep) in
                            this case ALL the factors will get the defined
                            concentration on the defined timestep.
                            (Default: None)
                            *WARNING, as above.

  Arguments:
     <infile>: A valid transsys program file. (.tra)
    <outfile>: The output file, the printout.

  *Both arguments are optional as the program is able to read/write from the
 STDIN/STDOUT in case of one/two arguments are ommited.
"""


class GaussianRNG:
  """Constructs a random object. By calling the random_gauss method produce
a "random" number out of a Gauss distribution"""

  def __init__(self, rndseed, mu, sigma):
    self.rng   = random.Random(rndseed)
    self.mu    = mu
    self.sigma = sigma

  def randomValue(self):
    return self.rng.gauss(self.mu, self.sigma)


class ConstantRNG:
  # A "random" series of "1" will be produced!
    def __init__(self, constValue):
      self.constValue = constValue

    def randomValue(self):
      return self.constValue



class TranssysInstanceCoordinates(transsys.TranssysInstance) :
  """Subclass of TranssyInstance, contains the coordinate of the instance in
the lattice model.
    Legacy Code don't use anymore, since there are incompatibilities with the
TranssysInstance class of the transsys module.
  """
  def __init__(self, tp, coords=None, timestep=None) :
    transsys.TranssysInstance.__init__(self, tp, timestep)
    self.coordinates = []

  def time_series(self, num_timesteps) :
    """Overrides time_series and produces a timeseries with
TranssysInstanceCoordinates instances."""
    timeseries = transsys.TranssysInstance.time_series(self, num_timesteps)
    # This list contains the timeseries with the coordinates.
    tsCoordinates = []
    for t in timeseries:
      a = TranssysInstanceCoordinates(t.transsys_program, t.timestep)
      a.transsys_program = t.transsys_program
      a.timestep = t.timestep
      a.factor_concentration = t.factor_concentration
      a.factor_concentration_stddev = t.factor_concentration_stddev
      a.factor_concentration_entropy = t.factor_concentration_entropy
      a.coordinates = self.coordinates
      tsCoordinates.append(a)
    return tsCoordinates


class TranssysProgramLattice(transsys.TranssysInstanceCollection) :
  """This class contains a lattice of transsys programs. The main object of
the simulation, is a subclass of the TranssysInstanceCollection of the
__init__.py module. The lattice is in a two dimensional toroidal form."""

  def __init__(self, tp, n) :
    """The constructor of the class."""
    # The name of the lattice.
    self.name = tp.name + '_on_a_toroidal_two_dimentional_' + str(n) + 'x' + str(n) + '_lattice'
    self.lattice = self.lattice_generator(tp, n)
    self.transsysProgram = tp
    self.size = n
#    self.factorConcentrations = self.generate_factor_concentrations_lattice()


  def lattice_generator(self, tp, n) :
    """Generates a nxn lattice of transsys instances."""
    lattice = []
    for i in xrange(n) :
      lattice.append([])
      for j in xrange(n) :
        lattice[i].append(TranssysInstanceCoordinates(tp))
        lattice[i][j].coordinates = [(i + 1), (j + 1)]
#        lattice[i][j].coordinates.append(j + 1)
    return lattice


#  def generate_factor_concentrations_lattice(self) :
#    """Generates a list of lists with the factor concentrations. kept for
#legacy reasons this function is not used anymore.
#    factorConcentrationsLattice = []
#    for i in xrange(len(self.lattice)) :
#      factorConcentrationsLattice.append([])
#      for j in xrange(len(self.lattice[i])) :
#        factorConcentrationsLattice[i].append(self.lattice[i][j].factor_concentration)
#    return factorConcentrationsLattice


  def get_transsys_program(self) :
    """Overrides the get_transsys_program method of the superclass."""
    return self.transsysProgram


  def transsys_instance_list(self) :
    """Overrides the transsys_instance_list method of the superclass."""
    ti_list = []
    for i in xrange(len(self.lattice)) :
      for j in xrange(len(self.lattice[i])) :
        ti_list.append(self.lattice[i][j])
    return ti_list


  def write_table_header(self, f) :
    """Overrides the writre_table_header method of the superclass."""
    f.write('# Table of coordinated (i,j) factor concentrations (Header)\n')
    f.write('timestep i,j')
    for factor in self.transsysProgram.factor_list :
      f.write(' %s' % factor.name)
    f.write('\n')


  def write_table(self, f) :
    """Overrides the write_table method of the superclass."""
    for ti in self.transsys_instance_list() :
      if ti.timestep is None :
        f.write('NA')
      else :
        f.write('%i' % ti.timestep)
      if len(self.transsys_instance_list()) == 1 :
        f.write(' 1,1')
      else :
        f.write(' %i,%i' % (ti.coordinates[0], ti.coordinates[1]))
      for c in ti.factor_concentration :
        f.write(' %1.17e' % c)
      f.write('\n')


  def update_factor_concentrations(self, currentState, n, rndseed) :
    """The update function of the simulator, calculates the instances of the
next timestep. Careful usage of the factor concentrations..."""
    # First calculate the updated factor concentrations.
    # All the instances in the lattice are interacting with the 4 neighbour
    # cells, the instances in the edges are interacting with the opposite
    # cells forming the toroidal.
    latticeFactorConcentrations = []
    # Include some noise or not.
#    rng = GaussianRNG(rndseed, 0, 0.1)
    rng = ConstantRNG(0)
    for i in xrange(len(self.lattice)) :
      latticeFactorConcentrations.append([])
      for j in xrange(len(self.lattice[i])) :
        # The factor concentrations manipulation.
        factorConcentrationsUpdate = [0.0] * self.transsysProgram.num_factors()
        # Get the current lattice concentrations.
        factorConcentrationsOld = currentState[i][j].factor_concentration
        if len(factorConcentrationsOld) != len(factorConcentrationsUpdate) :
          raise StandardError, 'Factor number inconsistancy between the new and the old factor concentrations list.'
        for k in xrange(len(factorConcentrationsUpdate)) :
          # The main calculation of the new factor concentrations.
          # Introduce "per factor" diffusibility expression.
          p = self.transsysProgram.factor_list[k].diffusibility_expression.value
          # Check the toroidal transformations by using the modulo division!
          fc = (factorConcentrationsOld[k] + (rng.randomValue() + (p * self.lattice[(n + i - 1) % n][j].factor_concentration[k])) + (rng.randomValue() + (p * self.lattice[i][(n + j - 1) % n].factor_concentration[k])) + (rng.randomValue() + (p * self.lattice[i][(j + 1) % n].factor_concentration[k])) + (rng.randomValue() + (p * self.lattice[(i + 1) % n][j].factor_concentration[k]))) / (4 * p + 1)
          factorConcentrationsUpdate[k] = fc
        latticeFactorConcentrations[i].append(factorConcentrationsUpdate)
    return latticeFactorConcentrations


  def update_function(self, timesteps, rndseed) :
    """Calculates the new transsys instance."""
#    for n in xrange(timesteps) :
    # Produce a copy of the current state of the simulator.
    currentState = self.lattice ## Kludge
    updateFactorConcentrations = self.update_factor_concentrations(currentState, self.size, rndseed)
    for i in xrange(len(self.lattice)) :
      for j in xrange(len(self.lattice[i])) :
        if len(self.lattice[i][j].factor_concentration) != len(updateFactorConcentrations[i][j]) :
          raise StandardError, 'update_function Error. Factor number inconsistancy'
        else :
          self.lattice[i][j].factor_concentration = updateFactorConcentrations[i][j]
          # The timeseries doesn't work with timestep 1, returns zero.
          # Thats why a timestep = 2 is used.
          # FIXME: The number of timesteps of each transsys instance on the
          # lattice timeseries is awlays one because of the usage of timestep
          # one all the time. Update it, to take the number of the current
          # timestep.
          self.lattice[i][j] = self.lattice[i][j].time_series(2)[1]
          self.lattice[i][j].timestep = (timesteps + 1)


  def introduce_signal(self, signalC, xFactor = None) :
    """Sets the factor concentration of a declared factor to the declared value. """
    # Check for the existance of the xFactor.
    if xFactor != None :
      if not xFactor in self.transsysProgram.factor_names() :
        raise StandardError, 'Factor %s is not a valid %s factor name. Please specify a valid factor name.' % (xFactor, self.transsysProgram.name)
    # Find the center of the lattice. If the lattice size is an even number,
    # then assume the 4 central cells as center.
    if divmod(self.size, 2)[1] == 1 :
      i = divmod(self.size, 2)[0]
      j = divmod(self.size, 2)[0]
      # Set all the factor concentrations to signalConcentration.
      # Alternatively, set a randomly choosen factor concentration.
#      k = random.randint(0, (self.ranssysProgram.num_factors() - 1))
#      self.lattice[i][j].factor_concentration[k] = random.gauss(signalC, 1)
      # Set a specific factor concentration to a given value.
      if xFactor == None :
        self.lattice[i][j].factor_concentration = [signalC for fc in self.lattice[i][j].factor_concentration]
      elif xFactor :
        k = self.transsysProgram.find_factor_index(xFactor)
        self.lattice[i][j].factor_concentration[k] = signalC
    elif divmod(self.size, 2)[1] == 0 :
      q = divmod(self.size, 2)[0]
      k = random.randint(0, (self.transsysProgram.num_factors() - 1))
      for i in xrange(q - 1, q + 1) :
        for j in xrange(q - 1, q + 1) :
          # Alternatively, set a randomly choosen factor concentration.
#          k = random.randint(0, (self.transsysProgram.num_factors() - 1))
#          self.lattice[i][j].factor_concentration[k] = random.gauss(signalC, 1)
          # Set a specific factor concentration to a given value.
          if xFactor == None :
            self.lattice[i][j].factor_concentration = [signalC for fc in self.lattice[i][j].factor_concentration]
          elif xFactor :
            k = self.transsysProgram.find_factor_index(xFactor)
            self.lattice[i][j].factor_concentration[k] = signalC



class LatticeFigure :
  """Construct an image(in a raw image format) out of a transsys lattice."""

  def __init__(self, transsysLattice, cd) :
    self.figure = self.produce_row_format(transsysLattice, cd)


  # Function kept for lecgacy reasons after the introduction of the user defined
  # maximum accepted factor concentration value, there is no need for this
  # anymore.
  def flatten_lattice(self, factorConcentrationsLattice) :
    """Flattens the factor concentration lattice to a single list. Kept for
legacy reasons this function is not called anymore."""
    flatfactorConcentrations = []
    for i in xrange(len(factorConcentrationsLattice)) :
      for j in xrange(len(factorConcentrationsLattice[i])) :
        for fc in factorConcentrationsLattice[i][j] :
          flatfactorConcentrations.append(fc)
    return flatfactorConcentrations


  def produce_row_format(self, transsysLattice, maxC) :
   """Produces the raster image file. Suitable for view/analyse with the
Netpbm and/or Imagemagick graphics package."""
   # Generate the apropriate .pgm image format.
   pgmMagic = 'P2' # .pgm file magic line, P2 for .pgm, 
   pgmComment = '# ' + transsysLattice.name + ' .pgm image of ' + ' timestep'
   pgmSize = str(transsysLattice.size)
   pgmMaxval = 255
   pgmRaster = ''
   # Code kept for legacy reasons, after the introduction of the user defined
   # maximum accepted factor concentration for the image gradient, this rather
   # strange approach has been replaced by a more resonable one.
   # All this approach has been substitute with a simplier way to deal with the color range of the images. Check the next code chunks.
#   flattenFCL = self.flatten_lattice(transsysLattice.generate_factor_concentrations_lattice())
#   maxValue = math.ceil(max(flattenFCL))
#   # Not so nice trick to avoid division by zero later.
#   if maxValue == 0.0 :
#     maxValue = 1e-99
   for i in xrange(transsysLattice.size) :
     pgmRasterLine = ''
     for j in xrange(transsysLattice.size) :
#       # Calibration within the color interval.
#       # The calibration procesure has been simplified now and a user defined 
#       # maximum printing factor concentration has been introduced, Keeping
#       # this code for legacy reasons..
#       p = pgmMaxval - int(math.floor(((sum(transsysLattice.lattice[i][j].factor_concentration)) / (len(transsysLattice.lattice[i][j].factor_concentration) * maxValue) * pgmMaxval)))
       # The new simplified way to deal with the color gradients versus factor
       # concentrations.
       #FIXME: this should simplified more and produce one image file for EACH
       # factor at more complicated transsys programs.
       p = pgmMaxval - int(round(((sum(transsysLattice.lattice[i][j].factor_concentration) * pgmMaxval) / maxC)))
       pgmRasterLine = pgmRasterLine + str(p) + ' '
     pgmRaster = pgmRaster + pgmRasterLine + '\n'
   pgmText = pgmMagic + '\n' + pgmComment + '\n' + pgmSize + ' ' + pgmSize + '\n' + str(pgmMaxval)  + '\n' + pgmRaster
   return pgmText



# Simulation Parameter Initialization.
latticeSize           = 5
noTimesteps           = 30
randomSeed            = 1
maxConcentration      = 10.0
signalT               = False
signalF               = False
animate               = False
#signalTimestep        = 10
#signalConcentration   = 10



# Command line parsing.
try :
  optlist, args = getopt.getopt(sys.argv[1:], 'a h m: n: r: s: t: x:', ['help'])
except getopt.GetoptError, errorMessage :
  errorMessage = 'Error in arguments parsing, please give -h or --help for help '
  print errorMessage
  sys.exit(1)

for opt, par in optlist :
  if opt in ('-h', '--help') :
    usage()
    sys.exit()
  if opt in ('-n') :
    latticeSize = int(par)
  if opt in ('-t') :
    noTimesteps = int(par)
  if opt in ('-r') :
    randomSeed = float(par)
  if opt in ('-m') :
    maxConcentration = float(par)
  if opt in ('-x') :
    var = par.split(':')
    if len(var) != 2 :
      raise TypeError, 'Error in the format of -x input options, please check the help (--help) for more information.'
    if float(var[0]) :
    # No need to raise an exeption Python will raise one for you!!!
#      raise TypeError, 'Please give a valid floating point representation for the concentration parameter, Check help (--help) for more information.'
      signalT = True
      signalConcentration = float(var[0])
      signalTimestep = int(var[1])
  if opt in ('-s') :
    var = par.split(':')
    if len(var) != 2 :
      raise TypeError, 'Error in the format of -s input options, please check the help (--help) for more information.'
    if float(var[1]) :
      signalF = True
      xFactorName = var[0]
      xFactorConcentration = float(var[1])
  if opt in ('-a') :
    animate = True

#print optlist


# I/O manipulation.
if len(args) > 0 :
  infile = open(args[0], 'r')
else :
  infile = sys.stdin
if len(args) > 1 :
  outfile = open(args[1], 'w')
else :
  outfile = sys.stdout


###############
## Main program.
# Instantiate and parse the transsys program.
transsysProgram  = transsys.TranssysProgramParser(infile).parse()
# Close the input file.
if infile is not sys.stdin :
  infile.close()

# Instantiate the lattice of transsys programs class.
tpl = TranssysProgramLattice(transsysProgram, latticeSize)

# Check the transsys program for acceptable diffusibility parameters.
# Diffusibility ought to be a number between 0 and 1 [0, 1] for the
# update_function to work well.
for i in transsysProgram.factor_list :
  if float(i.diffusibility_expression.value) <= 1.0 :
    continue
  else :
    raise StandardError, 'Diffusibility expression error, please check the transsys program, the lattice works only with floating numbers between 0 and 1'


###################
# Run the simulator

#tpl.update_function(interactionPercentage, 1, randomSeed)

#for i in xrange(len(tpl.lattice)) :
#  for j in xrange(len(tpl.lattice)) :
#    outfile.write(repr(tpl.lattice[i][j].factor_concentration))
#  outfile.write()


# Use the os module to make a directory with all the images of timesteps.
# First check for the existance of the directory.
if os.path.exists(transsysProgram.name) :
  shutil.rmtree(transsysProgram.name)
# Make a directory named from the transsys program name, and change to it.
os.mkdir(transsysProgram.name)
os.chdir(transsysProgram.name)

# Introduce the signal by specifing a factor and the desired concentration.
if signalF :
  tpl.introduce_signal(xFactorConcentration, xFactorName)

# Instantiate the figure class.
figure = LatticeFigure(tpl, maxConcentration)

# The update calculations.
tpl.write_table_header(outfile)
#latticeTime_series = []
statList = [] # The statistics list.
for i in xrange(noTimesteps + 1) :
  # Introduce the signal in the signal Timestep.
  if signalT :
    if i == (signalTimestep):
      tpl.introduce_signal(signalConcentration)
  # Calculate the statistics.
  statList.append(tpl.statistics())
  # Write the table to outfile.
  tpl.write_table(outfile)
  # Open the graphics file.
  filename = '%04d' % (i + 1) + '.pgm'
  figureFile = open(filename, 'w')
  # Produce the raster graphics files.
  s = figure.produce_row_format(tpl, maxConcentration)
  figureFile.write(s)
  figureFile.close()
  # Calculate the new lattice instance.
  tpl.update_function(i, randomSeed)


# Image file conversion and animation. (Optional)
if animate :
  # Convert the images to a more readable format.
  for imageFile in os.listdir('./') :
#    os.system('cp ' + str(imageFile) + ' ' + str(imageFile) + '_OLD')
    os.system('convert -sample 320x320 ' + str(imageFile) + ' ' + str(imageFile) + '.CONV')
  # Animate.
  os.system('animate -delay 50 *.pgm.CONV &')

# Return to the current directory.
os.chdir(os.pardir)


# Print the results of statistics to an .R compatible file.
# Print the header of the file.
outfile.write('# Statistics file for testing and further analysis (Header).\n')
outfile.write('timestep:\tfactor:\taverage:\tstddev:\tentropy:\n')
for i, stat in enumerate(statList) :
  for f in stat.transsys_program.factor_list :
    outfile.write('%i\t%s\t%f\t%e\t%e\n' % (i, f.name, stat.average[stat.transsys_program.find_factor_index(f.name)], stat.standard_deviation[stat.transsys_program.find_factor_index(f.name)], stat.shannon_entropy[stat.transsys_program.find_factor_index(f.name)]))


# Close the output file.
if outfile is not sys.stdout :
  outfile.close()

sys.exit()
