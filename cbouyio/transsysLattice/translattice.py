#!/usr/bin/env python

# $Rev::               $:  Revision of last commit
# $Author::            $:  Author of last commit
# $Date$:  Date of last commit

"""translattice.py

Contain the objects for building structured 2D transsys systems.

A 2D toroidal shaped grid (lattice) is the main structure that has been
implemented until now.

@author: Costas Bouyioukos
@organization: University of East Anglia
@since: Aprill 2006 (converted to a module on 08/09/2006)
@copyright: The program is coming as it is. You have the right to redistribute,
transform and change the source code presuming the apropriate reference and
the lisence is kept free.
@license: GNU GPL3 or newer.
@contact: U{Costas Bouyioukos<mailto:konsb@cmp.uea.ac.uk>}
@version: $Id$
"""

# Indicate the program version
__version__ = "$Id$"

# latticeSimulator: A program that simulates a lattice of trannsys instances
# on a nxn lattice, each cell of the lattice cantains one transsys program.
# The program applies communication between neighbour cells and is an attempt
# to simulate the processes described in "Soile V. E. Keranen, 2004. Simulation
# study on effects of signaling network structure on the developmental
# increase in complexity."
# Start developing as a program by CBouyio on Aprill 2006 at UEA.
# Converted to a module (transsyslattice.py) at 08/09/2006 by CBouyio at UEA.


import random
import copy
import cPickle

import transsys



class RandomObject(object) :
  """Empty superclass where all the random number generators' classes rae
  subclassing from.

  """
  pass


class GaussianRNG(RandomObject) :
  """Class of random objects out of a Gaussian distribution.

  By calling the random.gauss method, produce a "random" number out of a
  Gaussian distribution.

  @ivar rng: The random number object, generated by a call to the
  random.Random() method of Python's random module.
  @type rng: C{class 'random.Random'}
  @ivar mu: The mean of the Gaussian distribution.
  @type mu: C{float} or C{int}
  @ivar sigma: The standard deviation of the Gaussian distribution.
  @type sigma: C{float} or C{int}
  @ivar rndSeed: The random seed of the random number generator.
  @type rndSeed: C{int}
  """

  def __init__(self, rndseed, mu, sigma):
    """Constrauctor of the class.

    Takes the random seed, the mean and the standard deviation.

    @param rndseed: The random seed of the random number generator.
    @type rndseed: C{int}
    @param mu: The mean of the Gaussian distribution.
    @type mu: C{float} or C{int}
    @param sigma: The standard deviation of the Gaussian distribution.
    @type sigma: C{float} or C{int}
    """
    if not isinstance(rndseed, int):
      raise StandardError, 'The random number generator accepts only integers.'
    self.rng   = random.Random(rndseed)
    self.mu    = mu
    self.sigma = sigma
    self.rndSeed = rndseed


  def random_value(self):
    """Common method among all xxxxRNG classes.

    Returns a random number generated by the random.gauss Python function.

    @return: A random number from a Gaussian Distribution.
    @rtype: C{float}
    """
    return self.rng.gauss(self.mu, self.sigma)


class UniformRNG(RandomObject):
  """Class of random objects out of a Uniform distribution.

  By calling the random.uniform method, produces a "random" number out of a
  Uniform distribution.

  @ivar rng: The random number object, generated by a call to the
  random.Random() method of Python's random module.
  @type rng: C{class 'random.Random'}
  @ivar lower: the lower bound for the uniform distribution.
  @type lower: C{int} or C{float}
  @ivar upper: The upper bound for the uniform distribution.
  @type upper: C{int} or C{float}
  @ivar rndSeed: The random seed of the random number generator.
  @type rndSeed: C{int}
  """
  def __init__(self, rndseed, lowerB, upperB):
    """Constructor of the class.

    Takes only the random seed as parameter.

    @param rndseed: The random seed of the random number generator.
    @type rndseed: C{int}
    @param lowerB: The left border of a Uniform distribution.
    @type lowerB: C{float} or C{int}
    @param upperB: The right border of a Uniform distribution.
    @type upperB: C{float} or C{int}
    @return: A random number from a Uniform Distribution.
    """
    if not isinstance(rndseed, int):
      raise StandardError, 'The random number generator accepts only integers.'
    self.rng = random.Random(rndseed)
    self.lower = lowerB
    self.upper = upperB
    self.rndSeed = rndseed

  def random_value(self):
    """Common method among all xxxxRNG classes.

    Returns a random number generated by the random.uniform Python function,
    the number belongs to the [lower, upper) interval.

    @rtype: C{float}
    """
    return self.rng.uniform(self.lower, self.upper)


class ConstantRNG(RandomObject):
  """Class of "random" objects with constant values.

  Basicaly for control reasons, the class actually generates constant numbers.

  @ivar constValue: A number.
  @type constValue: C{float} or C{int}
  """
  # A "random" series of "constValue" will be produced!!!
  def __init__(self, constValue):
    """Constructor of the class.

    The only instance variable is the constant value.

    @param constValue: An arbitarily chosen number.
    @type constValue: Numeric
    """
    self.constValue = constValue

  def random_value(self):
    """Returns the constant value.

    @return: The constant number.
    @rtype: C{float} or C{int}
    """
    return self.constValue



class FactorValueParameter(object) :
  """Class to represent a factor-value pair parameter.

  Usually this parameter is implemented as a
  <factor_name>:<factor_concentration> pair.
  @ivar factorName: A transsys factor name.
  @type factorName: C{string} as unresolved
  @ivar concentration: The factor's concentration value.
  @type concentration: Numeric
  """

  def __init__(self, factorName, concentration) :
    """The constructor of the class

    """
    if not isinstance(factorName, str) :
      raise StandardError, "Error in parameter settings. Factor name should always be a string."
    self.factorName = factorName
    self.concentration = concentration



class Parameter(object) :
  """Superclass to represent a parameter.

  This is a class of parameters that do not contain a single value. Complex
  types of parameters include: parameters for the random initial conditions or
  the  lattice size, or for the control points of engineered transsys programs.
  This superclass provides a universall printing method for these complex
  parameters.
  """

  def __str__(self) :
    """Try to print the parameter's values as best as posible..

    """
    string = ''
    for k, v in self.__dict__.iteritems() :
      string = string + '%s: %s ' % (str(k), str(v))
    return string



class LatticeSize(Parameter) :
  """Class to represent the size of the lattice. Width and hight.

  @ivar width: The width of the lattice
  @type width: C{int}
  @ivar hight: The height of the lattice.
  @type hight: C{int}
  """

  def __init__(self, a, b) :
    """The constructor

    """
    if not isinstance(a, int) and not isinstance(b, int) :
      raise StandardError, "Only integers can be valid lattice size parameters."
    self.width = a
    self.height = b



class UniformParameters(Parameter) :
  """Class to represent the lower and upper bound required to define a uniform
  distribution.

  @ivar lower: The lower bound of a uniform distribution.
  @type lower: C{int} or C{float}
  @ivar upper: The upper bound of a uniform distribution.
  @type upper: C{int} or C{float}
  """

  def __init__(self, a, b) :
    """The constructor, also incorporates some tests.

    """
    if isinstance(a, (float, int,)) and isinstance(b, (float, int,)) :
      if a <= b :
        self.lower = a
        self.upper = b
      if a > b :
        self.lower = b
        self.upper = a
    else :
      raise TypeError, 'A float or an integer are valid numeric argumenets for the uniform distribution parameters.'


  def getRNG(self, rndSeed) :
    """Method to construct the random number generator.

    Returns a Uniform random number generator.
    @param rndSeed: the random seed for the random number generator.
    @type rndSeed: C{int}
    @requires: An integer random seed.
    @return: A random number generator object of the form xxxxRNG.
    @rtype: C{class 'RandomObject'}
    """
    return UniformRNG(rndSeed, self.lower, self.upper)




class GaussianParameters(Parameter) :
  """Class to represent the variables (mean, stddev) to define a Gaussian
  distribution.

  @ivar mean: The mean of a Gaussian distribution.
  @type mean: C{int} or C{float}
  @ivar stddev: The standard deviation of a Gaussian distribution.
  @type stddev: C{int} or C{float}
  """

  def __init__(self, a, b) :
    """The constructor and some tests (i.e check for positive stddev)

    """
    if b < 0 :
      raise TypeError, 'Error in the gaussian distribution parameters. Standard deviation should always be a positive number.'
    self.mean = a
    self.stddev = b


  def getRNG(self, rndSeed) :
    """Method to construct the random number generator.

    Returns a Gaussian random number generator.
    @param rndSeed: the random seed for the random number generator.
    @type rndSeed: C{int}
    @requires: An integer random seed.
    @return: A random number generator object of the form xxxxRNG.
    @rtype: C{class 'RandomObject'}
    """
    return GaussianRNG(rndSeed, self.mean, self.stddev)



class SignalTimestep(Parameter) :
  """A class to represent the signal/timestep parameter.

  @ivar timestep: The timestep at which the signal should be implemented.
  @type timestep: C{int}
  @ivar signal: The signal, that is the factor concentration, that all factors
  should acquire in the specified timestep.
  @type signal: C{int} or C{float}

  """

  def __init__(self, a, b) :
    """The constructor and checks that both values are positive and timestep is
    integer.

    """
    if a < 0 or b < 0 :
      raise TypeError, 'Both arguments for the signal/timestep parameter should be positive.'
    if isinstance(b, int) and isinstance(a, (int, float,)) :
      self.signal = a
      self.timestep = b
    else :
      raise TypeError, 'Check the type of the signal timestep parameter'



class ControlParameters(object) :
  """Superclass for control parameters. Implements some common methods for the
  various control parameters classes.

  """

  def __str__(self) :
    """Try to print as best as possible the instance variables of any control
    parameter class.
    """
    string = ''
    for ivar, value in self.__dict__.iteritems() :
      string = string + '# %s: %s\n' % (str(ivar), str(value))
    return string


class SimulatorControlParameters(ControlParameters) :
  """Class to collect and represent the simulator's control parameters.

  @ivar latticeSize: The size of the lattice, should be a L{LatticeSize}
  object. Mandatory control parameter
  @type latticeSize: C{class 'LatticeSize'}
  @ivar timesteps: The number of timesteps that the simulator is running.
  Mandatory control parameter
  @type timesteps: C{int}
  @ivar randomSeed: The seed of the random number generators. (Default = 1)
  @type randomSeed: C{int}
  @ivar samplingInterval: The sampling interval for the time_series method.
  (default = 1)
  @type samplingInterval: C{int}
  @ivar initialisationVariables: The variables for the random initialisation of
  the factor concentrations. Can be either a L{GaussianParameters} or an
  L{UniformParameters} object.
  @type initialisationVariables: C{class 'GaussianParameters'} or
  C{class 'UniformParameters'}
  @ivar factorInitialisation: Parameter to initialise factor concentrations to
  user specified values.
  @ivar signalTimestep: A signal (set all factors' concentration to the
  specified value) at a specified timestep.
  @todo: Implement a factor initialisation dictionary class and therelevant
  instance variable.
  """

  def __init__(self, latticeSize, timesteps, initialisationVariables = None, factorInitialisation = None, signalTimestep = None, randomSeed = 1, samplingInterval = 1) :
    """The constructor of the class

    Note that the only mandatory parameters are the size of the lattice and the
    number of timesteps, the two default parameters are the random seed and the
    sampling intervals and all the rest are optional parameters all sett to
    'None'
    """
    if not isinstance(latticeSize, LatticeSize) :
      raise StandardError, 'Error in lattice size parameter passing. A lattice size parameter should be an instance of LatticeSize'
    self.latticeSize = latticeSize
    if not isinstance(timesteps, int) :
      raise StandardError, 'Only integers can be valid timesteps parameter.'
    self.timesteps = timesteps
    if not isinstance(randomSeed, int) :
      raise StandardError, 'Only integers are accepted from the current random number generator.'
    self.randomSeed = randomSeed
    if not isinstance(samplingInterval, int) :
      raise StandardError, 'Only integers can be valid sampling interval parameter.'
    self.samplingInterval = samplingInterval
    if initialisationVariables and not isinstance(initialisationVariables, (UniformParameters, GaussianParameters,)) :
      raise StandardError, 'The initialisation variables should be either a UniformParameters or a GaussianParameters instance.'
    self.initialisationVariables = initialisationVariables
    if signalTimestep and not isinstance(signalTimestep, SignalTimestep) :
      raise StandardError, 'The signal-timestep paramter should be a SignalTimestep object.'
    self.signalTimestep = signalTimestep
    #FIXME: Implement the factor initalisation class.
    self.factorInitialisation = factorInitialisation



class TranssysInstanceCoordinated(transsys.TranssysInstance):
  """Extended L{transsys.TranssysInstance} class.

  Provides the TranssysInstance objects with an additional functionality,
  theirs Cartesian coordinates on the lattice.

  @ivar transsys_program: A valid transsys program.
  @type transsys_program: C{class 'transsys.TranssysProgram'}
  @ivar timestep: The number of timesteps that the simulator runs.
  @type timestep: C{int}
  @ivar factor_concentration: A list containing the factor concentrations.
  @type factor_concentration: C{list} of C{float}s
  @ivar xCoord: The x-coordinate of the instance.
  @type xCoord: C{int}
  @ivar yCoord: The y-coordinate of the instance.
  @type yCoord: C{int}
  """

  def __init__(self, tp, xCoord=None, yCoord=None, timestep=None):
    """Constructor of the class, overrides the TranssysInstance constructor.

    The coordinates of a transsys instance are stored in a list.

    @param tp: A valid transsys program.
    @type tp: C{class 'transsys.TranssysProgram'}
    @param xCoord: The x-coordinate of the instance.
    @type xCoord: C{int}
    @param yCoord: The y-coordinate of the instance.
    @type yCoord: C{int}
    @param timestep: The number of timesteps that the simulator runs.
    @type timestep: C{int}
    """
#    transsys.TranssysInstance.__init__(self, tp, timestep)
    # No need to call the old constructor, fc_stddev and fc_entropy are
    # obsolate in this context. They have been implemented in the
    # transsys.statistics class.
    self.transsys_program = tp
    self.timestep = timestep
    self.numFactors = self.transsys_program.num_factors()
    self.factor_concentration = [0.0] * self.numFactors
    self.x = xCoord
    self.y = yCoord


  def time_series(self, num_timesteps, sampling_period=1, lsys_lines=None, lsys_symbol=None):
    """Override the time_series method with a timeseries containing
    TranssysInstanceCoordinated instances instead.

    @param num_timesteps: The number of steps (runs) of the timeseries.
    @type num_timesteps: C{int}
    @returns: A list of TranssysInstanceCoordinated instances (The length of
    list equals the number of timesteps).
    @rtype: C{list} of C{TranssysInstanceCoordinated} objects
    """
    timeseries = transsys.TranssysInstance.time_series(self, num_timesteps)
    # This list will get the timeseries with the coordinates.
    tsCoordinated = []
    for ti in timeseries:
      coordTI = TranssysInstanceCoordinated(ti.transsys_program, ti.timestep)
      coordTI.transsys_program = ti.transsys_program
      coordTI.timestep = ti.timestep
      coordTI.factor_concentration = ti.factor_concentration
     # No need to override these the new class doesn't need them, check
     # comments at the constructor of the class as well.
#      a.factor_concentration_stddev = t.factor_concentration_stddev
#      a.factor_concentration_entropy = t.factor_concentration_entropy
      coordTI.x = self.x
      coordTI.y = self.y
      tsCoordinated.append(coordTI)
    return tsCoordinated



class TranssysInstanceLattice(transsys.TranssysInstanceCollection):
  """The central class of the simulator, represents a 2D lattice of
  L{TranssysInstanceCoordinated} objects.

  All the methods for the representation and simulation of a two dimensional
  toroidal lattice are implemented in this class.
  The methods of the TranssysInstanceCollection are also inherrited.

  @ivar name: The lattice name. Contains information of the type and the size
  of the structure.
  @type name: C{str}
  @ivar lattice: A lattice containg a transsys instance in each cell.
  @type lattice: C{list} of C{list} of C{transsys.TranssysInstance} objects
  @ivar transsysProgram: The transsys program.
  @type transsysProgram: C{class 'transsys.TranssysProgram'}
  @ivar latticeSize: An object of L{LatticeSize} which holds the dimensions of
  the lattice.
  @type latticeSize: C{class 'LatticeSize'}
  @ivar timestep: The timestep.
  @type timestep: C{int}
  @ivar numFactors: The number of factors of the transsys program.
  @type numFactors: C{int}
  """

  def __init__(self, tp, size, timestep=None):
    """Constructor of the class.

    @param tp: The transsys program.
    @type tp: C{class 'transsys.TranssysProgram'}
    @param size: An instance of an L{LatticeSize} object to represent the
    size of the lattice..
    @type size: a L{LatticeSize} object
    @param timestep: The timestep.
    @type timestep: C{int}
    """
    # Call the base class constructor.
    transsys.TranssysInstanceCollection.__init__(self)
    self.transsysProgram = tp
    self.latticeSize = size
    # The name of the lattice.
    self.name = tp.name + '_on_a_' + str(self.latticeSize.width) + 'x' + str(self.latticeSize.height) + '_lattice_with_periodic_boundaries'
    self.timestep = timestep
    self.lattice = self.lattice_generator()
    # Safeguard for acceptable diffusibility parameters.
    # Diffusibility ought to be a number between 0 and 1 [0, 1] to be accepted
    # by the update function.
    for factor in self.transsysProgram.factor_list :
      if 0.0 <= float(factor.diffusibility_expression.value) <= 1.0 :
        continue
      else :
        raise StandardError, 'Diffusibility expression error. The accepted diffusibility values resides within the range of 0.0 to 1.0 [0.0, 1.0]'
    self.numFactors = self.transsysProgram.num_factors()


  def lattice_generator(self):
    """Populate the lattice with one transsys program instance at each cell.

    Works with 2D lattices untill now....

    @return: A <width>x<height> lattice populated with transsys instances.
    @rtype: C{list} of C{list} of C{transsys.TranssysInstance} objects
    """
    lattice = []
    for i in xrange(self.latticeSize.width):
      lattice.append([])
      for j in xrange(self.latticeSize.height):
        lattice[i].append(TranssysInstanceCoordinated(self.transsysProgram, i+1, j+1))
    return lattice


  def perturb_factor(self, fc, perturbObj):
    """Return a perturbed value of a factor concentration.

    This function clips (rejects) possible negative factor concentration values
    that might generated by the perturbation procedure.
    @param fc: The factor concentration.
    @type fc: C{float}
    @param perturbObj: A random object of the class L{RandomObject}.
    @type perturbObj: C{class 'RandomObject'}
    @todo: Implement the homogenisation switch, basicaly it can be a constant
    random object!
    """
    fcP = fc + perturbObj.random_value()
    # The next line rejects negative values for factor concentration.
    if fcP < 0 :
      return self.perturb_factor(fc, perturbObj) # Might exceed the maximum
                                                 #number of recursions if the
                                                 #perturbation object is not
                                                 #chosen carefully.
    return fcP


  def perturb_lattice(self, perturbObj):
    """Perturb the factor concentrations of all factors on a lattice.

    Wraper of the previous method L{perturb_factor} for all the factors on
    the lattice.
    The result of this function depends on the type of the random object that
    it is called with. (either a UnifromRNG or a gaussianRNG)
    @param perturbObj: A perturbation random object L{RandomObject}.
    @type perturbObj: C{class 'RandomObject'}
    @rtype: C{None}
    """
    if not isinstance(perturbObj, RandomObject) :
      raise StandardError, 'Lattice initialisation error. The lattice can be initialised only with a random object.'
    for i in xrange(self.latticeSize.width):
      for j in xrange(self.latticeSize.height):
        self.lattice[i][j].factor_concentration = map(lambda fc: self.perturb_factor(fc, perturbObj), self.lattice[i][j].factor_concentration)


  def get_transsys_program(self):
    """Overrides the get_transsys_program method of the superclass.

    Returns a transsys program.

    @return: A C{transsys.TranssysProgram} object
    @rtype: C{class 'transsys.TranssysProgram'}
    """
    return self.transsysProgram


  def transsys_instance_list(self):
    """Overrides the transsys_instance_list method of the superclass.

    Returns a list of all the transsys instances from a
    TranssysInstanceCollection.

    @return: The transsys instances contained on the lattice.
    @rtype: C{list} of C{transsys.TranssysInstance} objects
    """
    tiList = []
    for i in xrange(self.latticeSize.width):
      for j in xrange(self.latticeSize.height):
        tiList.append(self.lattice[i][j])
    return tiList


  def write_table_header(self, outfile, rndseed=None):
    """Overrides the write_table_header method of the superclass.

    Writes to the output file the header of the factor's table.
    (compatible to R)

    @param outfile: An open for writing C{file} object.
    @type outfile: C{file}
    @param rndseed: The random seed of the simulator.
    @type rndseed: C{int}
    @rtype: C{None}
    @precondition: An open, ready for writting file object.
    """
    outfile.write('# Table of coordinated (x, y) factor concentrations (Header file)\n')
    outfile.write('# random seed: %i \n' % rndseed)
    outfile.write('timestep x y')
    for factor in self.transsysProgram.factor_list :
      outfile.write(' %s' % factor.name)
    outfile.write('\n')


  def write_table(self, outfile):
    """Overrides the write_table method of the superclass.

    Writes at the output file the factor table (factor concentrations) for each
    factor of each transsys program in each timestep of the simulator.

    @param outfile: An open for writing C{file} object.
    @type outfile: C{file}
    @rtype: C{None}
    @precondition: An open, ready for writting file object.
    """
    for ti in self.transsys_instance_list():
      if self.timestep is None :
        outfile.write('NA')
      else :
        outfile.write('%i' % self.timestep)
      outfile.write(' %i %i' % (ti.x, ti.y))
      for fc in ti.factor_concentration :
        outfile.write(' %1.17e' % fc)
      outfile.write('\n')


  def expression_table(self) :
    """Method to extract a factor expression table.

    The table has rows = <num_factors> and columns = <num_instances>, therefore
    is a <factors>x<instnaces> table containing the factor concentrations.
    @return: A factor x instances factor concentration table.
    @rtype: C{list} of {list}s of {float}s
    """
    exprTable = []
    for i in xrange(self.transsysProgram.num_factors()) :
      exprVector = []
      for ti in self.transsys_instance_list() :
        exprVector.append(ti.factor_concentration[i])
      exprTable.append(exprVector)
    return exprTable


  def get_factor_expression_profile(self, factorName) :
    """Return the factor expression profile of the lattice

    @return: The expression profile of the specified factor from the lattice.
    The same function can apply to any C{transsys.TranssysInstanceCollection}
    object.
    @rtype: C{list} of C{float}s
    """
    # Method is not needed anymore it has implemented in a higher lever (i.e.
    # the TranssysInstanceCollection class)
    raise StandardError, 'This method is obsolete should not be called anymore. Try the equivalent method of the superclass'
#    factorExpression = []
#    factorIndex = self.transsysProgram.find_factor_index(factorName)
#    for ti in self.transsys_instance_list() :
#      factorExpression.append(ti.factor_concentration[factorIndex])
#    return factorExpression


  def update_factor_concentrations(self, currentState):
    """Update function of the simulator, calculates the factor concentrations
    of the next timestep.

    Careful usage of factor concentrations diffusibilities and noise...!

    The method calculates the new factor concentrations after the calculation
    of all the diffusibility effects and returns the lattice list with the
    "updated" factor concentrations.

    @param currentState: A transsys program lattice.
    @type currentState: C{class 'TranssysInstanceLattice'}
    @return: A list of lists of lists of factor concentrations, after the
    diffusibility effects have been calculated.
    @rtype: C{list} of C{list}s of C{list}s
    """
    # Calculate the updated factor concentrations.
    # All the instances in the lattice are interacting with the 4 neighbour
    # cells, the instances in the edges are interacting with the opposite
    # cells forming the toroidal.
    # First assign the dimensions of the lattice.
    x = self.latticeSize.width
    y = self.latticeSize.height
    latticeFactorConcentrations = []
    # Begin the calculations.
    for i in xrange(x) :
      latticeFactorConcentrations.append([])
      for j in xrange(y) :
        # The factor concentrations manipulation.
        factorConcentrationNew = [0.0] * self.numFactors
        # Get the current lattice concentrations.
        factorConcentrationOld = currentState[i][j].factor_concentration
#        if len(factorConcentrationOld) != len(factorConcentrationNew):
#          raise StandardError, 'Factor number inconsistancy between the new and the old factor concentrations list.'
        for k in xrange(len(factorConcentrationNew)):
          # The main calculation of the new factor concentrations.
          # Introduce "per factor" diffusibility expression.
          diffRate = self.transsysProgram.factor_list[k].diffusibility_expression.value
          # Check the toroidal transformations by using the modulo division!
          if diffRate == 0.0 :
            factorConcentrationNew[k] = factorConcentrationOld[k]
          else :
            fcNew = (factorConcentrationOld[k] + diffRate * self.lattice[(x + i - 1) % x][j].factor_concentration[k] + diffRate * self.lattice[i][(y + j - 1) % y].factor_concentration[k] + diffRate * self.lattice[i][(j + 1) % y].factor_concentration[k] + diffRate * self.lattice[(i + 1) % x][j].factor_concentration[k]) / (4 * diffRate + 1)
            factorConcentrationNew[k] = fcNew
        latticeFactorConcentrations[i].append(factorConcentrationNew)
    return latticeFactorConcentrations


  def update_function(self, timesteps):
    """Updates the transsys lattice instance at the next timestep.

    The method first updates the factor concentrations by calling the
    L{update_factor_concentrations} function, and then calculates the new
    instance of the lattice (next timestep) by calling the
    L{TranssysInstanceCoordinated.time_series} for all the
    TranssysInstanceCoordinated on the lattice (it's a wrapper).

    @param timesteps: The number of timestep that the simulator has reached.
    @type timesteps: C{int}
    @rtype: C{None}
    """
    # First calculate all the factor concentrations after diffusion.
    updateFactorConcentrations = self.update_factor_concentrations(self.lattice)
    # Then set the lattice's factor concentration to the new ones.
    for i in xrange(len(self.lattice)):
      for j in xrange(len(self.lattice[i])):
#        if len(self.lattice[i][j].factor_concentration) != len(updateFactorConcentrations[i][j]):
#          raise StandardError, 'update_function Error. Factor number inconsistancy'
        self.lattice[i][j].factor_concentration = updateFactorConcentrations[i][j]
        # The timeseries doesn't work with timestep 1, returns zero.
        # Thats why a timestep = 2 is used.
        self.lattice[i][j] = self.lattice[i][j].time_series(2).pop()
        # Then set the timestep.
        self.lattice[i][j].timestep = timesteps


  def timestep_factor_concentration(self, signalC):
    """Set all the factor concentrations on the lattice to signal.

    Set, at the specified timestep, the concentrations of all factors to the
    signalC value.

    @param signalC: The concentration of the signal.
    @type signalC: C{float}
    @rtype: C{None}
    """
    for i in xrange(self.latticeSize.width):
      for j in xrange(self.latticeSize.height):
        self.lattice[i][j].factor_concentration = [signalC for fc in self.lattice[i][j].factor_concentration]


  def signal_factor_concentration(self, initDict, i = 0, j = 0):
    """Set factors' concentration to user defined values.

    Function changes the factor concentration of the defiened factors before
    the begining of the simulator.
    Alters the factors concentrations ONLY at the "first" cell of the simulator
    (coordinates (1, 1) which acts as a signal.
    Factor concentration values contained in a dictionary and are defined by
    the user

    @param initDict: A dictionary contains the user defined factor
    concentration values in the pair {FactorName:FactorConcentration}
    @type initDict; C{dict}
    @param i: The abscissa of the coordinates.
    @type i: C{int}
    @param j: The ordinate of the coordinates.
    @type j: C{int}
    @rtype: C{None}
    @precondition: The keys of the dictionary should be valid factor names of
    the corresponding transsys program, the values positive floating point
    numbers.
    """
    # Check for the existance of the signal factors.
    tp = self.transsysProgram
    for factName in initDict.iterkeys():
      if factName not in tp.factor_names():
        raise StandardError, "Specified factor doean't exist in transsys program. Check the factor names of the (-s) option."
    # Set the factor concentrations.
    for factName, concentration in initDict.iteritems():
      self.lattice[i][j].factor_concentration[tp.find_factor_index(factName)] = float(concentration)



class TranssysLatticeTimeseries(object):
  """Class to represent the timeseries of the lattice simulator.

  Keep record of all the important things during the simulation process.
  The position of the transsys instances on the lattice the timestep and the
  factor(s) concentration(s).

  Also calulates the maximum value of factor concentration that is observed
  during the simulation proccess.

  @ivar transsysLatticeName: The transsys lattice name. Contains information
  of the type and the size of the structure.
  @type transsysLatticeName: C{str}
  @ivar timesteps: The number of timesteps of the simulation.
  @type timesteps: C{int}
  @ivar samplingInterval: The interval between sampling.
  @type samplingInterval: C{int}
  @ivar latticeTimeseries: A list containing all the transsys lattice
  instances of each timestep of the simulator.
  @type latticeTimeseries: C{list} of C{TranssysInstanceLattice}
  objects
  @ivar maxFactorConcentration: The maximum factor concentration observed in
  the simulation.
  @type maxFactorConcentration: C{float}
  """


  def __init__(self, transsysLattice, timesteps, samplingInterval = 1, timestepSignal = None):
    """Constructor of the class.

    @param transsysLattice: A transsys instance lattice object.
    L{TranssysInstanceLattice}
    @type transsysLattice: C{class 'TranssysInstanceLattice'}
    @param timesteps: The number of timesteps of the simulation.
    @type timesteps: C{int}
    @param samplingInterval: The interval between sampling.
    @type samplingInterval: C{int}
    @param timestepSignal: The signal to alter factor concentrations on a
    specific timestep
    type timestepSignal: C{int}:C{float}
    """
#    self.factorTable = factor_table(fileObject)
    self.transsysLatticeName = transsysLattice.name
    self.timesteps = timesteps
    self.samplingInterval = samplingInterval
    self.latticeTimeseries = self.transsys_lattice_timeseries(transsysLattice, timesteps, samplingInterval, timestepSignal)
#    self.maxFactorConcentration = self.max_factor_concentration()


  def transsys_lattice_timeseries(self, transsysLattice, timesteps, samplingInterval, timestepSignal=None):
    """Keep all the L{TranssysInstanceLattice} instances in a list.

    Return a timeseries (list) of C{TranssysInstanceLattice} objects for all
    the simulation procedure.

    @param transsysLattice: A transsys lattice.
    @type transsysLattice: C{class 'TranssysInstanceLattice'}
    @param timesteps; The number of timesteps of the simulator.
    @type timesteps: C{int}
    @param samplingInterval: The interbval between sampling.
    @type samplingInterval: C{int}
    @param timestepSignal: The timestep signal parameter. Defines the factor
    concentration and the timestep that it will be introduced (to all factors
    untill now)
    @type timestepSignal: C{class 'Parameter'}
    @return: A list with all the C{TranssysInstanceLattice} instances of the
    simulator.
    @rtype: C{list} of C{TranssysInstanceLattice} objects
    """
    latticeTimeseries = []
    # Iterate for timestep + 1 to include the initial (zero) timestep. 
    for i in xrange(timesteps + 1):
      transsysLattice.timestep = i
      if timestepSignal :
        if i == timestepSignal.timestep :
          transsysLattice.timestep_factor_concentration(timestepSignal.signal)
      # Append the deepcopy according to the sampling intervals.
      if i % samplingInterval == 0 :
        latticeTimeseries.append(copy.deepcopy(transsysLattice))
      transsysLattice.update_function(i)
    return latticeTimeseries


  def write_factor_table(self, infile):
    """Write the whole factor table in a file.

    Calls the L{TranssysInstanceLattice.write_table} for the whole transsys
    lattice timeseries.

    @param infile: An open file object ready for writing.
    @type infile: C{file}
    @rtype: C{None}
    @precondition: An open, ready for writting file object.
    """
    # Write the whole timeseries table.
    for til in self.latticeTimeseries :
      til.write_table(infile)


  # This function was needed only witrht he old animation approach. Obsolete
  # after the complete R animation approach. Therefore the max_concentration
  # instance variable des not exist anymore.
  def max_factor_concentration(self, factorName=None):
    """The maximal observed factor concentration of a specified factor.

    Return the maximum value of a factor concentration that has been observed
    during the whole simulation proccess.
    If it is called without specifing a factor name calculates the maximum
    concentration value of all factors.

    @param factorName: The name of the factor that we maximum is wanted.
    @type factorName: C{str}
    @return: Maximum of factor concentration.
    @rtype: C{float}
    """
    # method become obsolete after the abolition of the .pgm imaging framework.
    maxFC = 0.0
    for til in self.latticeTimeseries :
      for ti in til.transsys_instance_list():
        if not factorName :
          for fc in ti.factor_concentration :
            if fc > maxFC :
              maxFC = fc
        else :
          factorIndex = ti.transsys_program.find_factor_index(factorName)
          fc = ti.factor_concentration[factorIndex]
          if fc > maxFC :
            maxFC = fc
    return maxFC


  def factor_table(self, fileObj):
    """Return the factor table from a file that contains it.

    @todo: The return value might be usefull as an instance variable...
    @param fileObj: An open file object ready for reading.
    @type fileObj: C{file}
    @rtype: C{str}
    @precondition: An open, ready for reading file object.
    """
    factorTable = fileObj.read()
    return factorTable




def pickle(object):
  """Return the pickled representation of the object as a string.

  @returns: A string representing the pickled object.
  @rtype: C{str}
  """
  return cPickle.dumps(object)


def unpickle(fileObj):
  """Reconstruct and return the original odject hierarchy from its pickled file.

  @returns: The pickled object.
  @rtype: C{class 'object'}
  @precondition: An open, ready for reading file object, containing a pickled
  object.
  """
  return cPickle.load(fileObj)


def print_summary_statistics(tlt, fileObj):
  """Calculate and print the collection statistics of the simulator.

  The actual calculation of the statistics is implemented in the
  L{transsys.CollectionStatistics} class.
  (This function is a wrapper).

  @param tlt: A transsys lattice timeseries.
  @type tlt: C{class 'TranssysLatticeTimeseries'}
  @param fileObj: An open ready for writting file object.
  @type fileObj: C{file}
  @precondition: An open, ready for writting file object.
  """
  statList = []
  for til in tlt :
    statList.append(til.statistics())
  fileObj.write('# Summary file for aggregate statistics (Header)\n')
  fileObj.write('timestep\tfactor\taverage\tstddev\tentropy\n')
  for i, stat in enumerate(statList):
    for factor in stat.transsys_program.factor_list :
      fName = factor.name
      fileObj.write('%i\t%s\t%f\t%e\t%e\n' % (tlt[i].timestep, fName, stat.average[stat.transsys_program.find_factor_index(fName)], stat.standard_deviation[stat.transsys_program.find_factor_index(fName)], stat.shannon_entropy[stat.transsys_program.find_factor_index(fName)]))

